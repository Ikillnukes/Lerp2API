<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lerp2API</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:SimplexNoise.Noise" -->
        <member name="M:SimplexNoise.Noise.Generate(System.Single)">
            <summary>
            1D simplex noise
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:SimplexNoise.Noise.Generate(System.Single,System.Single)">
            <summary>
            2D simplex noise
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="F:cVoronoiMap.m_Noise1">
            The noise used for generating Voronoi seeds
        </member>
        <member name="F:cVoronoiMap.m_CellSize">
            Size of the Voronoi cells (avg X/Y distance between the seeds). Expected to be at least 2. 
        </member>
        <member name="F:cVoronoiMap.m_JitterSize">
            The amount that the cell seeds may be offset from the grid.
            	Expected to be at least 1 and less than m_CellSize. 
        </member>
        <member name="F:cVoronoiMap.m_OddRowOffset">
            The constant amount that the cell seeds of every odd row will be offset from the grid.
            	This allows us to have non-rectangular grids.
            	Expected to be between -m_CellSize and +m_CellSize. 
        </member>
        <member name="F:cVoronoiMap.m_CurrentCellX">
            The X coordinate of the currently cached cell neighborhood 
        </member>
        <member name="F:cVoronoiMap.m_CurrentCellZ">
            The Z coordinate of the currently cached cell neighborhood 
        </member>
        <member name="F:cVoronoiMap.m_SeedX">
            The seeds of cells around m_CurrentCellX, m_CurrentCellZ, X-coords 
        </member>
        <member name="F:cVoronoiMap.m_SeedZ">
            The seeds of cells around m_CurrentCellX, m_CurrentCellZ, X-coords 
        </member>
        <member name="M:cVoronoiMap.SetCellSize(System.Int32)">
            Sets both the cell size and jitter size used for generating the Voronoi seeds. 
        </member>
        <member name="M:cVoronoiMap.SetJitterSize(System.Int32)">
            Sets the jitter size. Clamps it to current cell size. 
        </member>
        <member name="M:cVoronoiMap.SetOddRowOffset(System.Int32)">
            Sets the offset that is added to each odd row of cells.
            	This offset makes the voronoi cells align to a non-grid.
            	Clamps the value to [-m_CellSize, +m_CellSize]. 
        </member>
        <member name="M:cVoronoiMap.GetValueAt(System.Int32,System.Int32)">
            Returns the value in the cell into which the specified point lies. 
        </member>
        <member name="M:cVoronoiMap.GetValueAt(System.Int32,System.Int32,System.Int32@)">
            Returns the value in the cell into which the specified point lies,
            	and the distance to the nearest Voronoi seed. 
        </member>
        <member name="M:cVoronoiMap.GetValueAt(System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            Returns the value in the cell into which the specified point lies,
            	and the distances to the 2 nearest Voronoi seeds. Uses a cache. 
        </member>
        <member name="M:cVoronoiMap.FindNearestSeeds(System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            Finds the nearest and second nearest seeds, returns their coords. 
        </member>
        <member name="M:cVoronoiMap.UpdateCell(System.Int32,System.Int32)">
            Updates the cached cell seeds to match the specified cell. Noop if cell pos already matches.
            	Updates m_SeedX and m_SeedZ. 
        </member>
        <member name="T:ScottGarland.BigInteger">
             <summary>
             Represents a integer of abitrary length.
             </summary>
             <remarks>
             <para>
             A BigInteger object is immutable like System.String. The object can not be modifed, and new BigInteger objects are
             created by using the operations of existing BigInteger objects.
             </para>
             <para>
             Internally a BigInteger object is an array of ? that is represents the digits of the n-place integer. Negative BigIntegers
             are stored internally as 1's complements, thus every BigInteger object contains 1 or more padding elements to hold the sign.
             </para>
             </remarks>
             <example>
             <code>
             public class MainProgram
             {
            		[STAThread]
            		public static void Main(string[] args)
            		{
            			BigInteger a = new BigInteger(25);
            			a = a + 100;
            
            			BigInteger b = new BigInteger("139435810094598308945890230913");
            
            			BigInteger c = b / a;
            			BigInteger d = b % a;
            
            			BigInteger e = (c * a) + d;
            			if (e != b)
            			{
            				Console.WriteLine("Can never be true.");
            			}
            		}
            	</code>
             </example>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor">
            <summary>
            Create a BigInteger with an integer value of 0.
            </summary>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.Int64)">
            <summary>
            Creates a BigInteger with the value of the operand.
            </summary>
            <param name="number">A long.</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.UInt64)">
            <summary>
            Creates a BigInteger with the value of the operand. Can never be negative.
            </summary>
            <param name="number">A unsigned long.</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.Byte[])">
            <summary>
            Creates a BigInteger initialized from the byte array.
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a BigInteger initialized from the byte array ending at <paramref name="length" />.
            </summary>
            <param name="array">A byte array.</param>
            <param name="length">Int number of bytes to use.</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a BigInteger initialized from <paramref name="length" /> bytes starting at <paramref name="offset" />.
            </summary>
            <param name="array">A byte array.</param>
            <param name="offset">Int offset into the <paramref name="array" />.</param>
            <param name="length">Int number of bytes.</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.String)">
            <summary>
            Creates a BigInteger in base-10 from the parameter.
            </summary>
            <remarks>
             The new BigInteger is negative if the <paramref name="digits" /> has a leading - (minus).
            </remarks>
            <param name="digits">A string</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Creates a BigInteger in base and value from the parameters.
            </summary>
            <remarks>
             The new BigInteger is negative if the <paramref name="digits" /> has a leading - (minus).
            </remarks>
            <param name="digits">A string</param>
            <param name="radix">A int between 2 and 36.</param>
        </member>
        <member name="M:ScottGarland.BigInteger.#ctor(ScottGarland.DigitsArray)">
            <summary>
            Copy constructor, doesn't copy the digits parameter, assumes <code>this</code> owns the DigitsArray.
            </summary>
            <remarks>The <paramef name="digits" /> parameter is saved and reset.</remarks>
            <param name="digits"></param>
        </member>
        <member name="P:ScottGarland.BigInteger.IsNegative">
            <summary>
            A bool value that is true when the BigInteger is negative (less than zero).
            </summary>
            <value>
            A bool value that is true when the BigInteger is negative (less than zero).
            </value>
        </member>
        <member name="P:ScottGarland.BigInteger.IsZero">
            <summary>
            A bool value that is true when the BigInteger is exactly zero.
            </summary>
            <value>
            A bool value that is true when the BigInteger is exactly zero.
            </value>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Implicit(System.Int64)~ScottGarland.BigInteger">
            <summary>
            Creates a BigInteger from a long.
            </summary>
            <param name="value">A long.</param>
            <returns>A BigInteger initialzed by <paramref name="value" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Implicit(System.UInt64)~ScottGarland.BigInteger">
            <summary>
            Creates a BigInteger from a ulong.
            </summary>
            <param name="value">A ulong.</param>
            <returns>A BigInteger initialzed by <paramref name="value" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Implicit(System.Int32)~ScottGarland.BigInteger">
            <summary>
            Creates a BigInteger from a int.
            </summary>
            <param name="value">A int.</param>
            <returns>A BigInteger initialzed by <paramref name="value" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Implicit(System.UInt32)~ScottGarland.BigInteger">
            <summary>
            Creates a BigInteger from a uint.
            </summary>
            <param name="value">A uint.</param>
            <returns>A BigInteger initialzed by <paramref name="value" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Addition(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Adds two BigIntegers and returns a new BigInteger that represents the sum.
            </summary>
            <param name="leftSide">A BigInteger</param>
            <param name="rightSide">A BigInteger</param>
            <returns>The BigInteger result of adding <paramref name="leftSide" /> and <paramref name="rightSide" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Add(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Adds two BigIntegers and returns a new BigInteger that represents the sum.
            </summary>
            <param name="leftSide">A BigInteger</param>
            <param name="rightSide">A BigInteger</param>
            <returns>The BigInteger result of adding <paramref name="leftSide" /> and <paramref name="rightSide" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Increment(ScottGarland.BigInteger)">
            <summary>
            Increments the BigInteger operand by 1.
            </summary>
            <param name="leftSide">The BigInteger operand.</param>
            <returns>The value of <paramref name="leftSide" /> incremented by 1.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Increment(ScottGarland.BigInteger)">
            <summary>
            Increments the BigInteger operand by 1.
            </summary>
            <param name="leftSide">The BigInteger operand.</param>
            <returns>The value of <paramref name="leftSide" /> incremented by 1.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Subtraction(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Substracts two BigIntegers and returns a new BigInteger that represents the sum.
            </summary>
            <param name="leftSide">A BigInteger</param>
            <param name="rightSide">A BigInteger</param>
            <returns>The BigInteger result of substracting <paramref name="leftSide" /> and <paramref name="rightSide" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Subtract(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Substracts two BigIntegers and returns a new BigInteger that represents the sum.
            </summary>
            <param name="leftSide">A BigInteger</param>
            <param name="rightSide">A BigInteger</param>
            <returns>The BigInteger result of substracting <paramref name="leftSide" /> and <paramref name="rightSide" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Decrement(ScottGarland.BigInteger)">
            <summary>
            Decrements the BigInteger operand by 1.
            </summary>
            <param name="leftSide">The BigInteger operand.</param>
            <returns>The value of the <paramref name="leftSide" /> decremented by 1.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Decrement(ScottGarland.BigInteger)">
            <summary>
            Decrements the BigInteger operand by 1.
            </summary>
            <param name="leftSide">The BigInteger operand.</param>
            <returns>The value of the <paramref name="leftSide" /> decremented by 1.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_UnaryNegation(ScottGarland.BigInteger)">
            <summary>
            Negates the BigInteger, that is, if the BigInteger is negative return a positive BigInteger, and if the
            BigInteger is negative return the postive.
            </summary>
            <param name="leftSide">A BigInteger operand.</param>
            <returns>The value of the <paramref name="this" /> negated.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Negate">
            <summary>
            Negates the BigInteger, that is, if the BigInteger is negative return a positive BigInteger, and if the
            BigInteger is negative return the postive.
            </summary>
            <returns>The value of the <paramref name="this" /> negated.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Abs(ScottGarland.BigInteger)">
            <summary>
            Creates a BigInteger absolute value of the operand.
            </summary>
            <param name="leftSide">A BigInteger.</param>
            <returns>A BigInteger that represents the absolute value of <paramref name="leftSide" />.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Multiply(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Multiply two BigIntegers returning the result.
            </summary>
            <remarks>
            See Knuth.
            </remarks>
            <param name="leftSide">A BigInteger.</param>
            <param name="rightSide">A BigInteger</param>
            <returns></returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Multiply(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Multiply two BigIntegers returning the result.
            </summary>
            <param name="leftSide">A BigInteger.</param>
            <param name="rightSide">A BigInteger</param>
            <returns></returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Division(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Divide a BigInteger by another BigInteger and returning the result.
            </summary>
            <param name="leftSide">A BigInteger divisor.</param>
            <param name="rightSide">A BigInteger dividend.</param>
            <returns>The BigInteger result.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Divide(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Divide a BigInteger by another BigInteger and returning the result.
            </summary>
            <param name="leftSide">A BigInteger divisor.</param>
            <param name="rightSide">A BigInteger dividend.</param>
            <returns>The BigInteger result.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.op_Modulus(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Perform the modulus of a BigInteger with another BigInteger and return the result.
            </summary>
            <param name="leftSide">A BigInteger divisor.</param>
            <param name="rightSide">A BigInteger dividend.</param>
            <returns>The BigInteger result.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Modulus(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Perform the modulus of a BigInteger with another BigInteger and return the result.
            </summary>
            <param name="leftSide">A BigInteger divisor.</param>
            <param name="rightSide">A BigInteger dividend.</param>
            <returns>The BigInteger result.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.CompareTo(ScottGarland.BigInteger)">
            <summary>
            Compare this instance to a specified object and returns indication of their relative value.
            </summary>
            <param name="value">An object to compare, or a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns>A signed number indicating the relative value of this instance and <i>value</i>.
            <list type="table">
            	<listheader>
            		<term>Return Value</term>
            		<description>Description</description>
            	</listheader>
            	<item>
            		<term>Less than zero</term>
            		<description>This instance is less than <i>value</i>.</description>
            	</item>
            	<item>
            		<term>Zero</term>
            		<description>This instance is equal to <i>value</i>.</description>
            	</item>
            	<item>
            		<term>Greater than zero</term>
            		<description>
            			This instance is greater than <i>value</i>.
            			<para>-or-</para>
            			<i>value</i> is a null reference (<b>Nothing</b> in Visual Basic).
            		</description>
            	</item>
            </list>
            </returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Compare(ScottGarland.BigInteger,ScottGarland.BigInteger)">
            <summary>
            Compare two objects and return an indication of their relative value.
            </summary>
            <param name="leftSide">An object to compare, or a null reference (<b>Nothing</b> in Visual Basic).</param>
            <param name="rightSide">An object to compare, or a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns>A signed number indicating the relative value of this instance and <i>value</i>.
            <list type="table">
            	<listheader>
            		<term>Return Value</term>
            		<description>Description</description>
            	</listheader>
            	<item>
            		<term>Less than zero</term>
            		<description>This instance is less than <i>value</i>.</description>
            	</item>
            	<item>
            		<term>Zero</term>
            		<description>This instance is equal to <i>value</i>.</description>
            	</item>
            	<item>
            		<term>Greater than zero</term>
            		<description>
            			This instance is greater than <i>value</i>.
            			<para>-or-</para>
            			<i>value</i> is a null reference (<b>Nothing</b> in Visual Basic).
            		</description>
            	</item>
            </list>
            </returns>
        </member>
        <member name="M:ScottGarland.BigInteger.Equals(System.Object)">
            <summary>
            Determines whether two Object instances are equal.
            </summary>
            <param name="obj">An <see cref="T:System.Object">Object</see> to compare with this instance.</param>
            <returns></returns>
            <seealso cref="T:System.Object">System.Object</seealso>
        </member>
        <member name="M:ScottGarland.BigInteger.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer has code.</returns>
            <seealso cref="T:System.Object">System.Object</seealso>
        </member>
        <member name="M:ScottGarland.BigInteger.ToString">
            <summary>
            Converts the numeric value of this instance to its equivalent base 10 string representation.
            </summary>
            <returns>A <see cref="T:System.String">String</see> in base 10.</returns>
            <seealso cref="T:System.Object">System.Object</seealso>
        </member>
        <member name="M:ScottGarland.BigInteger.ToString(System.Int32)">
            <summary>
            Converts the numeric value of this instance to its equivalent string representation in specified base.
            </summary>
            <param name="radix">Int radix between 2 and 36</param>
            <returns>A string.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.ToHexString">
            <summary>
            Returns string in hexidecimal of the internal digit representation.
            </summary>
            <remarks>
            This is not the same as ToString(16). This method does not return the sign, but instead
            dumps the digits array into a string representation in base 16.
            </remarks>
            <returns>A string in base 16.</returns>
        </member>
        <member name="M:ScottGarland.BigInteger.ToInt16(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.Int16 if possible.
            </summary>
            <param name="value"></param>
            <returns>Int value of BigInteger</returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.Int16</exception>
        </member>
        <member name="M:ScottGarland.BigInteger.ToUInt16(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.UInt16 if possible.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.UInt16</exception>
        </member>
        <member name="M:ScottGarland.BigInteger.ToInt32(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.Int32 if possible.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.Int32</exception>
        </member>
        <member name="M:ScottGarland.BigInteger.ToUInt32(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.UInt32 if possible.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.UInt32</exception>
        </member>
        <member name="M:ScottGarland.BigInteger.ToInt64(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.Int64 if possible.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.Int64</exception>
        </member>
        <member name="M:ScottGarland.BigInteger.ToUInt64(ScottGarland.BigInteger)">
            <summary>
            Returns BigInteger as System.UInt64 if possible.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.Exception">When BigInteger is too large to fit into System.UInt64</exception>
        </member>
        <member name="M:UniGif.GetTextureList(System.Byte[],System.Int32@,System.Int32@,System.Int32@,UnityEngine.FilterMode,UnityEngine.TextureWrapMode,System.Boolean)">
            <summary>
            Get GIF texture list (This is a possibility of lock up)
            </summary>
            <param name="bytes">GIF file byte data</param>
            <param name="loopCount">out Animation loop count</param>
            <param name="width">out GIF image width (px)</param>
            <param name="height">out GIF image height (px)</param>
            <param name="filterMode">Textures filter mode</param>
            <param name="wrapMode">Textures wrap mode</param>
            <param name="debugLog">Debug Log Flag</param>
            <returns>GIF texture list</returns>
        </member>
        <member name="M:UniGif.GetTextureListCoroutine(UnityEngine.MonoBehaviour,System.Byte[],System.Action{System.Collections.Generic.List{UniGif.GifTexture},System.Int32,System.Int32,System.Int32},UnityEngine.FilterMode,UnityEngine.TextureWrapMode,System.Boolean)">
            <summary>
            Get GIF texture list Coroutine (Avoid lock up but more slow)
            </summary>
            <param name="mb">MonoBehaviour to start the coroutine</param>
            <param name="bytes">GIF file byte data</param>
            <param name="cb">Callback method(param is GIF texture list, Animation loop count, GIF image width (px), GIF image height (px))</param>
            <param name="filterMode">Textures filter mode</param>
            <param name="wrapMode">Textures wrap mode</param>
            <param name="debugLog">Debug Log Flag</param>
            <returns>IEnumerator</returns>
        </member>
        <member name="T:UniGif.GifData">
            <summary>
            GIF Data Format
            </summary>
        </member>
        <member name="T:UniGif.ImageBlock">
            <summary>
            Image Block
            </summary>
        </member>
        <member name="T:UniGif.GraphicControlExtension">
            <summary>
            Graphic Control Extension
            </summary>
        </member>
        <member name="T:UniGif.CommentExtension">
            <summary>
            Comment Extension
            </summary>
        </member>
        <member name="T:UniGif.PlainTextExtension">
            <summary>
            Plain Text Extension
            </summary>
        </member>
        <member name="T:UniGif.ApplicationExtension">
            <summary>
            Application Extension
            </summary>
        </member>
        <member name="M:UniGif.DecodeTextureCoroutine(UniGif.GifData,System.Action{System.Collections.Generic.List{UniGif.GifTexture}},UnityEngine.FilterMode,UnityEngine.TextureWrapMode)">
            <summary>
            Decode to textures from GIF data
            </summary>
            <param name="gifData">GIF data</param>
            <param name="gifTexList">GIF texture list</param>
            <param name="filterMode">Textures filter mode</param>
            <param name="wrapMode">Textures wrap mode</param>
            <returns>IEnumerator</returns>
        </member>
        <member name="M:UniGif.DecodeTexture(UniGif.GifData,System.Collections.Generic.List{UniGif.GifTexture},UnityEngine.FilterMode,UnityEngine.TextureWrapMode)">
            <summary>
            Decode to textures from GIF data
            </summary>
            <param name="gifData">GIF data</param>
            <param name="gifTexList">GIF texture list</param>
            <param name="filterMode">Textures filter mode</param>
            <param name="wrapMode">Textures wrap mode</param>
            <returns>Result</returns>
        </member>
        <member name="M:UniGif.GetGlobalBgColor(UniGif.GifData)">
            <summary>
            Get background color from global color table
            </summary>
        </member>
        <member name="M:UniGif.GetDecodedData(UniGif.ImageBlock)">
            <summary>
            Get decoded image data from ImageBlock
            </summary>
        </member>
        <member name="M:UniGif.GetColorTable(UniGif.GifData,UniGif.ImageBlock,System.Nullable{UnityEngine.Color32}@)">
            <summary>
            Get color table (local or global)
            </summary>
        </member>
        <member name="M:UniGif.GetGraphicCtrlExt(UniGif.GifData,System.Int32)">
            <summary>
            Get GraphicControlExtension from GifData
            </summary>
        </member>
        <member name="M:UniGif.GetTransparentIndex(System.Nullable{UniGif.GraphicControlExtension})">
            <summary>
            Get transparent color index from GraphicControlExtension
            </summary>
        </member>
        <member name="M:UniGif.GetDelaySec(System.Nullable{UniGif.GraphicControlExtension})">
            <summary>
            Get delay seconds from GraphicControlExtension
            </summary>
        </member>
        <member name="M:UniGif.GetDisposalMethod(System.Nullable{UniGif.GraphicControlExtension})">
            <summary>
            Get disposal method from GraphicControlExtension
            </summary>
        </member>
        <member name="M:UniGif.CreateTexture2D(UniGif.GifData,System.Collections.Generic.List{UniGif.GifTexture},System.Int32,System.UInt16,UnityEngine.FilterMode,UnityEngine.TextureWrapMode,System.Boolean@)">
            <summary>
            Create Texture2D object and initial settings
            </summary>
        </member>
        <member name="M:UniGif.SetTexturePixelRow(UnityEngine.Texture2D,System.Int32,UniGif.ImageBlock,System.Byte[],System.Int32@,System.Collections.Generic.List{System.Byte[]},System.Nullable{UnityEngine.Color32},System.Int32,System.Boolean)">
            <summary>
            Set texture pixel row
            </summary>
        </member>
        <member name="M:UniGif.DecodeGifLZW(System.Collections.Generic.List{System.Byte},System.Int32,System.Int32)">
            <summary>
            GIF LZW decode
            </summary>
            <param name="compData">LZW compressed data</param>
            <param name="lzwMinimumCodeSize">LZW minimum code size</param>
            <param name="needDataSize">Need decoded data size</param>
            <returns>Decoded data array</returns>
        </member>
        <member name="M:UniGif.InitDictionary(System.Collections.Generic.Dictionary{System.Int32,System.String},System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Initialize dictionary
            </summary>
            <param name="dic">Dictionary</param>
            <param name="lzwMinimumCodeSize">LZW minimum code size</param>
            <param name="lzwCodeSize">out LZW code size</param>
            <param name="clearCode">out Clear code</param>
            <param name="finishCode">out Finish code</param>
        </member>
        <member name="M:UniGif.SortInterlaceGifData(System.Byte[],System.Int32)">
            <summary>
            Sort interlace GIF data
            </summary>
            <param name="decodedData">Decoded GIF data</param>
            <param name="xNum">Pixel number of horizontal row</param>
            <returns>Sorted data</returns>
        </member>
        <member name="M:UniGif.SetGifData(System.Byte[],UniGif.GifData@,System.Boolean)">
            <summary>
            Set GIF data
            </summary>
            <param name="gifBytes">GIF byte data</param>
            <param name="gifData">ref GIF data</param>
            <param name="debugLog">Debug log flag</param>
            <returns>Result</returns>
        </member>
        <member name="T:Extension">
            <summary>
            Extension methods class
            </summary>
        </member>
        <member name="M:Extension.GetNumeral(System.Collections.BitArray,System.Int32,System.Int32)">
            <summary>
            Convert BitArray to int (Specifies the start index and bit length)
            </summary>
            <param name="startIndex">Start index</param>
            <param name="bitLength">Bit length</param>
            <returns>Converted int</returns>
        </member>
        <member name="M:Extension.ToNumeral(System.Collections.BitArray)">
            <summary>
            Convert BitArray to int
            </summary>
            <returns>Converted int</returns>
        </member>
        <member name="T:FullSerializer.Internal.fsDateConverter">
            <summary>
            Supports serialization for DateTime, DateTimeOffset, and TimeSpan.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsEnumConverter">
            <summary>
            Serializes and deserializes enums by their current name.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsEnumConverter.ArrayContains``1(``0[],``0)">
            <summary>
            Returns true if the given value is contained within the specified array.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsGuidConverter">
            <summary>
            Serializes and deserializes guids.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsIEnumerableConverter">
            <summary>
            Provides serialization support for anything which extends from `IEnumerable` and has an `Add` method.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsIEnumerableConverter.GetElementType(System.Type)">
            <summary>
            Fetches the element type for objects inside of the collection.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsNullableConverter">
            <summary>
            The reflected converter will properly serialize nullable types. However, we do it here
            instead as we can emit less serialization data.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsWeakReferenceConverter">
            <summary>
            Serializes and deserializes WeakReferences.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsOption`1">
            <summary>
            Simple option type. This is akin to nullable types.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsPortableReflection">
            <summary>
            This wraps reflection types so that it is portable across different Unity runtimes.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the given attribute is defined on the given element.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.HasAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Returns true if the given attribute is defined on the given element.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.HasAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Returns true if the given attribute is defined on the given element.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.HasAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>
            Returns true if the given attribute is defined on the given element.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.GetAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>
            Fetches the given attribute from the given MemberInfo. This method applies caching
            and is allocation free (after caching has been performed).
            </summary>
            <param name="element">The MemberInfo the get the attribute from.</param>
            <param name="attributeType">The type of attribute to fetch.</param>
            <returns>The attribute or null.</returns>
        </member>
        <member name="M:FullSerializer.Internal.fsPortableReflection.GetAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Fetches the given attribute from the given MemberInfo.
            </summary>
            <typeparam name="TAttribute">The type of attribute to fetch.</typeparam>
            <param name="element">The MemberInfo to get the attribute from.</param>
            <param name="shouldCache">Should this computation be cached? If this is the only time it will ever be done, don't bother caching.</param>
            <returns>The attribute or null.</returns>
        </member>
        <member name="F:FullSerializer.Internal.fsVersionedType.Ancestors">
            <summary>
            The direct ancestors that this type can import.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsVersionedType.VersionString">
            <summary>
            The identifying string that is unique among all ancestors.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsVersionedType.ModelType">
            <summary>
            The modeling type that this versioned type maps back to.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsVersionedType.Migrate(System.Object)">
            <summary>
            Migrate from an instance of an ancestor.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsVersionManager.VerifyConstructors(FullSerializer.Internal.fsVersionedType)">
            <summary>
            Verifies that the given type has constructors to migrate from all ancestor types.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsVersionManager.VerifyUniqueVersionStrings(FullSerializer.Internal.fsVersionedType)">
            <summary>
            Verifies that the given version graph contains only unique versions.
            </summary>
        </member>
        <member name="T:FullSerializer.Internal.fsMetaProperty">
            <summary>
            A property or field on a MetaType. This unifies the FieldInfo and PropertyInfo classes.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsMetaProperty._memberInfo">
            <summary>
            Internal handle to the reflected member.
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.StorageType">
            <summary>
            The type of value that is stored inside of the property. For example, for an int field,
            StorageType will be typeof(int).
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.OverrideConverterType">
            <summary>
            A custom fsBaseConverter instance to use for this field/property, if requested. This will be
            null if the default converter selection algorithm should be used. This is specified using the
            [fsObject] annotation with the Converter field.
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.CanRead">
            <summary>
            Can this property be read?
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.CanWrite">
            <summary>
            Can this property be written to?
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.JsonName">
            <summary>
            The serialized name of the property, as it should appear in JSON.
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.MemberName">
            <summary>
            The name of the actual member.
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.IsPublic">
            <summary>
            Is this member public?
            </summary>
        </member>
        <member name="P:FullSerializer.Internal.fsMetaProperty.IsReadOnly">
            <summary>
            Is this type readonly? We can modify readonly properties using reflection, but not
            using generated C#.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsMetaProperty.Write(System.Object,System.Object)">
            <summary>
            Writes a value to the property that this MetaProperty represents, using given object
            instance as the context.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsMetaProperty.Read(System.Object)">
            <summary>
            Reads a value from the property that this MetaProperty represents, using the given
            object instance as the context.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsReflectionUtility.GetInterface(System.Type,System.Type)">
            <summary>
            Searches for a particular implementation of the given interface type inside of the type.
            This is particularly useful if the interface type is an open type, ie, typeof(IFace{}),
            because this method will then return IFace{} but with appropriate type parameters
            inserted.
            </summary>
            <param name="type">The base type to search for interface</param>
            <param name="interfaceType">The interface type to search for. Can be an open generic
            type.</param>
            <returns>The actual interface type that the type contains, or null if there is no
            implementation of the given interfaceType on type.</returns>
        </member>
        <member name="T:FullSerializer.Internal.fsTypeCache">
            <summary>
            Caches type name to type lookups. Type lookups occur in all loaded assemblies.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsTypeCache._cachedTypes">
            <summary>
            Cache from fully qualified type name to type instances.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsTypeCache._assembliesByName">
            <summary>
            Assemblies indexed by their name.
            </summary>
        </member>
        <member name="F:FullSerializer.Internal.fsTypeCache._assembliesByIndex">
            <summary>
            A list of assemblies, by index.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsTypeCache.TryDirectTypeLookup(System.String,System.String,System.Type@)">
            <summary>
            Does a direct lookup for the given type, ie, goes directly to the assembly identified by
            assembly name and finds it there.
            </summary>
            <param name="assemblyName">The assembly to find the type in.</param>
            <param name="typeName">The name of the type.</param>
            <param name="type">The found type.</param>
            <returns>True if the type was found, false otherwise.</returns>
        </member>
        <member name="M:FullSerializer.Internal.fsTypeCache.TryIndirectTypeLookup(System.String,System.Type@)">
            <summary>
            Tries to do an indirect type lookup by scanning through every loaded assembly until the
            type is found in one of them.
            </summary>
            <param name="typeName">The name of the type.</param>
            <param name="type">The found type.</param>
            <returns>True if the type was found, false otherwise.</returns>
        </member>
        <member name="M:FullSerializer.Internal.fsTypeCache.Reset">
            <summary>
            Removes any cached type lookup results.
            </summary>
        </member>
        <member name="M:FullSerializer.Internal.fsTypeCache.GetType(System.String)">
            <summary>
            Find a type with the given name. An exception is thrown if no type with the given name
            can be found. This method searches all currently loaded assemblies for the given type. If the type cannot
            be found, then null will be returned.
            </summary>
            <param name="name">The fully qualified name of the type.</param>
        </member>
        <member name="M:FullSerializer.Internal.fsTypeCache.GetType(System.String,System.String)">
            <summary>
            Find a type with the given name. An exception is thrown if no type with the given name
            can be found. This method searches all currently loaded assemblies for the given type. If the type cannot
            be found, then null will be returned.
            </summary>
            <param name="name">The fully qualified name of the type.</param>
            <param name="assemblyHint">A hint for the assembly to start the search with. Use null if unknown.</param>
        </member>
        <member name="T:FullSerializer.fsForwardAttribute">
             <summary>
             This allows you to forward serialization of an object to one of its members. For example,
            
             [fsForward("Values")]
             struct Wrapper {
               public int[] Values;
             }
            
             Then `Wrapper` will be serialized into a JSON array of integers. It will be as if `Wrapper`
             doesn't exist.
             </summary>
        </member>
        <member name="F:FullSerializer.fsForwardAttribute.MemberName">
            <summary>
            The name of the member we should serialize as.
            </summary>
        </member>
        <member name="M:FullSerializer.fsForwardAttribute.#ctor(System.String)">
            <summary>
            Forward object serialization to an instance member. See class comment.
            </summary>
            <param name="memberName">The name of the member that we should serialize this object as.</param>
        </member>
        <member name="T:FullSerializer.fsConverterRegistrar">
            <summary>
            This class allows arbitrary code to easily register global converters. To add a converter,
            simply declare a new field called "Register_*" that stores the type of converter you would
            like to add. Alternatively, you can do the same with a method called "Register_*"; just add
            the converter type to the `Converters` list.
            </summary>
        </member>
        <member name="T:FullSerializer.fsAotCompilationManager">
            <summary>
            The AOT compilation manager
            </summary>
        </member>
        <member name="P:FullSerializer.fsAotCompilationManager.AvailableAotCompilations">
            <summary>
            Ahead of time compilations that are available. The type maps to the object type the generated converter
            will serialize/deserialize, and the string is the text content for a converter that will do the serialization.
            <para />
            The generated serializer is completely independent and you don't need to do anything. Simply add the file to
            your project and it'll get used instead of the reflection based one.
            </summary>
        </member>
        <member name="M:FullSerializer.fsAotCompilationManager.TryToPerformAotCompilation(FullSerializer.fsConfig,System.Type,System.String@)">
            <summary>
            This is a helper method that makes it simple to run an AOT compilation on the given type.
            </summary>
            <param name="config">The configuration to use when running AOT compilation.</param>
            <param name="type">The type to perform the AOT compilation on.</param>
            <param name="aotCompiledClassInCSharp">The AOT class. Add this C# code to your project.</param>
            <returns>True if AOT compilation was successful.</returns>
        </member>
        <member name="M:FullSerializer.fsAotCompilationManager.AddAotCompilation(System.Type,FullSerializer.Internal.fsMetaProperty[],System.Boolean)">
            <summary>
            Adds a new AOT compilation unit.
            </summary>
            <param name="type">The type of object we are AOT compiling.</param>
            <param name="members">The members on the object which will be serialized/deserialized.</param>
        </member>
        <member name="M:FullSerializer.fsAotCompilationManager.GenerateDirectConverterForTypeInCSharp(System.Type,FullSerializer.Internal.fsMetaProperty[],System.Boolean)">
            <summary>
            AOT compiles the object (in C#).
            </summary>
        </member>
        <member name="T:FullSerializer.fsBaseConverter">
            <summary>
            The serialization converter allows for customization of the serialization process.
            </summary>
            <remarks>You do not want to derive from this class - there is no way to actually use it within
            the serializer.. Instead, derive from either fsConverter or fsDirectConverter</remarks>
        </member>
        <member name="F:FullSerializer.fsBaseConverter.Serializer">
            <summary>
            The serializer that was owns this converter.
            </summary>
        </member>
        <member name="M:FullSerializer.fsBaseConverter.CreateInstance(FullSerializer.fsData,System.Type)">
            <summary>
            Construct an object instance that will be passed to TryDeserialize. This should **not**
            deserialize the object.
            </summary>
            <param name="data">The data the object was serialized with.</param>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <returns>An object instance</returns>
        </member>
        <member name="M:FullSerializer.fsBaseConverter.RequestCycleSupport(System.Type)">
            <summary>
            If true, then the serializer will support cyclic references with the given converted
            type.
            </summary>
            <param name="storageType">The field/property type that is currently storing the object
            that is being serialized.</param>
        </member>
        <member name="M:FullSerializer.fsBaseConverter.RequestInheritanceSupport(System.Type)">
            <summary>
            If true, then the serializer will include inheritance data for the given converter.
            </summary>
            <param name="storageType">The field/property type that is currently storing the object
            that is being serialized.</param>
        </member>
        <member name="M:FullSerializer.fsBaseConverter.TrySerialize(System.Object,FullSerializer.fsData@,System.Type)">
            <summary>
            Serialize the actual object into the given data storage.
            </summary>
            <param name="instance">The object instance to serialize. This will never be null.</param>
            <param name="serialized">The serialized state.</param>
            <param name="storageType">The field/property type that is storing this instance.</param>
            <returns>If serialization was successful.</returns>
        </member>
        <member name="M:FullSerializer.fsBaseConverter.TryDeserialize(FullSerializer.fsData,System.Object@,System.Type)">
            <summary>
            Deserialize data into the object instance.
            </summary>
            <param name="data">Serialization data to deserialize from.</param>
            <param name="instance">The object instance to deserialize into.</param>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <returns>True if serialization was successful, false otherwise.</returns>
        </member>
        <member name="F:FullSerializer.fsGlobalConfig.IsCaseSensitive">
            <summary>
            Should deserialization be case sensitive? If this is false and the JSON has multiple members with the
            same keys only separated by case, then this results in undefined behavior.
            </summary>
        </member>
        <member name="F:FullSerializer.fsGlobalConfig.AllowInternalExceptions">
            <summary>
            If exceptions are allowed internally, then additional date formats can be deserialized.
            Note that the Full Serializer public API will *not* throw exceptions with this enabled;
            errors will still be returned in a fsResult instance.
            </summary>
        </member>
        <member name="F:FullSerializer.fsGlobalConfig.InternalFieldPrefix">
            <summary>
            This string will be used to prefix fields used internally by FullSerializer.
            </summary>
        </member>
        <member name="T:FullSerializer.fsConfig">
            <summary>
            Enables some top-level customization of Full Serializer.
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.SerializeAttributes">
            <summary>
            The attributes that will force a field or property to be serialized.
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.IgnoreSerializeAttributes">
            <summary>
            The attributes that will force a field or property to *not* be serialized.
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.DefaultMemberSerialization">
            <summary>
            The default member serialization.
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.GetJsonNameFromMemberName">
             <summary>
             Convert a C# field/property name into the key used for the JSON object. For example, you could
             force all JSON names to lowercase with:
            
                fsConfig.GetJsonNameFromMemberName = (name, info) => name.ToLower();
            
             This will only be used when the name is not explicitly specified with fsProperty.
             </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.EnablePropertySerialization">
             <summary>
             If false, then *all* property serialization support will be disabled - even properties
             explicitly annotated with fsProperty or any other opt-in annotation.
            
             Setting this to false means that SerializeNonAutoProperties and
             SerializeNonPublicSetProperties will be completely ignored.
             </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.SerializeNonAutoProperties">
            <summary>
            Should the default serialization behaviour include non-auto properties?
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.SerializeNonPublicSetProperties">
            <summary>
            Should the default serialization behaviour include properties with non-public setters?
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.CustomDateTimeFormatString">
            <summary>
            If not null, this string format will be used for DateTime instead of the default one.
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.Serialize64BitIntegerAsString">
            <summary>
            Int64 and UInt64 will be serialized and deserialized as string for compatibility
            </summary>
        </member>
        <member name="F:FullSerializer.fsConfig.SerializeEnumsAsInteger">
            <summary>
            Enums are serialized using their names by default. Setting this to true will serialize them as integers instead.
            </summary>
        </member>
        <member name="T:FullSerializer.fsContext">
            <summary>
            fsContext stores global metadata that can be used to customize how fsConverters operate
            during serialization.
            </summary>
        </member>
        <member name="F:FullSerializer.fsContext._contextObjects">
            <summary>
            All of the context objects.
            </summary>
        </member>
        <member name="M:FullSerializer.fsContext.Reset">
            <summary>
            Removes all context objects from the context.
            </summary>
        </member>
        <member name="M:FullSerializer.fsContext.Set``1(``0)">
            <summary>
            Sets the context object for the given type with the given value.
            </summary>
        </member>
        <member name="M:FullSerializer.fsContext.Has``1">
            <summary>
            Returns true if there is a context object for the given type.
            </summary>
        </member>
        <member name="M:FullSerializer.fsContext.Get``1">
            <summary>
            Fetches the context object for the given type.
            </summary>
        </member>
        <member name="T:FullSerializer.fsConverter">
            <summary>
            The serialization converter allows for customization of the serialization process.
            </summary>
        </member>
        <member name="M:FullSerializer.fsConverter.CanProcess(System.Type)">
            <summary>
            Can this converter serialize and deserialize the given object type?
            </summary>
            <param name="type">The given object type.</param>
            <returns>True if the converter can serialize it, false otherwise.</returns>
        </member>
        <member name="T:FullSerializer.fsDataType">
            <summary>
            The actual type that a JsonData instance can store.
            </summary>
        </member>
        <member name="T:FullSerializer.fsData">
            <summary>
            A union type that stores a serialized value. The stored type can be one of six different
            types: null, boolean, double, Int64, string, Dictionary, or List.
            </summary>
        </member>
        <member name="F:FullSerializer.fsData._value">
            <summary>
            The raw value that this serialized data stores. It can be one of six different types; a
            boolean, a double, Int64, a string, a Dictionary, or a List.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor">
            <summary>
            Creates a fsData instance that holds null.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.Boolean)">
            <summary>
            Creates a fsData instance that holds a boolean.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.Double)">
            <summary>
            Creates a fsData instance that holds a double.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.Int64)">
            <summary>
            Creates a new fsData instance that holds an integer.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.String)">
            <summary>
            Creates a fsData instance that holds a string.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.Collections.Generic.Dictionary{System.String,FullSerializer.fsData})">
            <summary>
            Creates a fsData instance that holds a dictionary of values.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.#ctor(System.Collections.Generic.List{FullSerializer.fsData})">
            <summary>
            Creates a fsData instance that holds a list of values.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.CreateDictionary">
            <summary>
            Helper method to create a fsData instance that holds a dictionary.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.CreateList">
            <summary>
            Helper method to create a fsData instance that holds a list.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.CreateList(System.Int32)">
            <summary>
            Helper method to create a fsData instance that holds a list with the initial capacity.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.BecomeDictionary">
            <summary>
            Transforms the internal fsData instance into a dictionary.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.Clone">
            <summary>
            Returns a shallow clone of this data instance.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsNull">
            <summary>
            Returns true if this fsData instance maps back to null.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsDouble">
            <summary>
            Returns true if this fsData instance maps back to a double.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsInt64">
            <summary>
            Returns true if this fsData instance maps back to an Int64.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsBool">
            <summary>
            Returns true if this fsData instance maps back to a boolean.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsString">
            <summary>
            Returns true if this fsData instance maps back to a string.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsDictionary">
            <summary>
            Returns true if this fsData instance maps back to a Dictionary.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.IsList">
            <summary>
            Returns true if this fsData instance maps back to a List.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsDouble">
            <summary>
            Casts this fsData to a double. Throws an exception if it is not a double.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsInt64">
            <summary>
            Casts this fsData to an Int64. Throws an exception if it is not an Int64.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsBool">
            <summary>
            Casts this fsData to a boolean. Throws an exception if it is not a boolean.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsString">
            <summary>
            Casts this fsData to a string. Throws an exception if it is not a string.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsDictionary">
            <summary>
            Casts this fsData to a Dictionary. Throws an exception if it is not a
            Dictionary.
            </summary>
        </member>
        <member name="P:FullSerializer.fsData.AsList">
            <summary>
            Casts this fsData to a List. Throws an exception if it is not a List.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.Cast``1">
            <summary>
            Internal helper method to cast the underlying storage to the given type or throw a
            pretty printed exception on failure.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.Equals(FullSerializer.fsData)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.op_Equality(FullSerializer.fsData,FullSerializer.fsData)">
            <summary>
            Returns true iff a == b.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.op_Inequality(FullSerializer.fsData,FullSerializer.fsData)">
            <summary>
            Returns true iff a != b.
            </summary>
        </member>
        <member name="M:FullSerializer.fsData.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table.</returns>
        </member>
        <member name="T:FullSerializer.fsDirectConverter">
            <summary>
            The direct converter is similar to a regular converter, except that it targets specifically only one type.
            This means that it can be used without performance impact when discovering converters. It is strongly
            recommended that you derive from fsDirectConverter{TModel}.
            </summary>
            <remarks>Due to the way that direct converters operate, inheritance is *not* supported. Direct converters
            will only be used with the exact ModelType object.</remarks>
        </member>
        <member name="T:FullSerializer.fsIgnoreAttribute">
            <summary>
            The given property or field annotated with [JsonIgnore] will not be serialized.
            </summary>
        </member>
        <member name="T:FullSerializer.fsISerializationCallbacks">
            <summary>
            Extend this interface on your type to receive notifications about serialization/deserialization events. If you don't
            have access to the type itself, then you can write an fsObjectProcessor instead.
            </summary>
        </member>
        <member name="M:FullSerializer.fsISerializationCallbacks.OnBeforeSerialize(System.Type)">
            <summary>
            Called before serialization.
            </summary>
        </member>
        <member name="M:FullSerializer.fsISerializationCallbacks.OnAfterSerialize(System.Type,FullSerializer.fsData@)">
            <summary>
            Called after serialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="data">The data that was serialized.</param>
        </member>
        <member name="M:FullSerializer.fsISerializationCallbacks.OnBeforeDeserialize(System.Type,FullSerializer.fsData@)">
            <summary>
            Called before deserialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="data">The data that will be used for deserialization.</param>
        </member>
        <member name="M:FullSerializer.fsISerializationCallbacks.OnAfterDeserialize(System.Type)">
            <summary>
            Called after deserialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="instance">The type of the instance.</param>
        </member>
        <member name="T:FullSerializer.fsJsonParser">
            <summary>
            A simple recursive descent parser for JSON.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonParser.SkipSpace">
            <summary>
            Skips input such that Character() will return a non-whitespace character
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonParser.TryParseNumber(FullSerializer.fsData@)">
            <summary>
            Parses numbers that follow the regular expression [-+](\d+|\d*\.\d*)
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonParser.TryParseString(System.String@)">
            <summary>
            Parses a string
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonParser.TryParseArray(FullSerializer.fsData@)">
            <summary>
            Parses an array
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonParser.Parse(System.String,FullSerializer.fsData@)">
            <summary>
            Parses the specified input. Returns a failure state if parsing failed.
            </summary>
            <param name="input">The input to parse.</param>
            <param name="data">The parsed data. This is undefined if parsing fails.</param>
            <returns>The parsed input.</returns>
        </member>
        <member name="M:FullSerializer.fsJsonParser.Parse(System.String)">
            <summary>
            Helper method for Parse that does not allow the error information
            to be recovered.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.InsertSpacing(System.IO.TextWriter,System.Int32)">
            <summary>
            Inserts the given number of indents into the builder.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.EscapeString(System.String)">
            <summary>
            Escapes a string.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.BuildPrettyString(FullSerializer.fsData,System.IO.TextWriter,System.Int32)">
            <summary>
            Formats this data into the given builder.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.PrettyJson(FullSerializer.fsData,System.IO.TextWriter)">
            <summary>
            Writes the pretty JSON output data to the given stream.
            </summary>
            <param name="data">The data to print.</param>
            <param name="outputStream">Where to write the printed data.</param>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.PrettyJson(FullSerializer.fsData)">
            <summary>
            Returns the data in a pretty printed JSON format.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.CompressedJson(FullSerializer.fsData,System.IO.StreamWriter)">
            <summary>
            Writes the compressed JSON output data to the given stream.
            </summary>
            <param name="data">The data to print.</param>
            <param name="outputStream">Where to write the printed data.</param>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.CompressedJson(FullSerializer.fsData)">
            <summary>
            Returns the data in a relatively compressed JSON format.
            </summary>
        </member>
        <member name="M:FullSerializer.fsJsonPrinter.ConvertDoubleToString(System.Double)">
            <summary>
            Utility method that converts a double to a string.
            </summary>
        </member>
        <member name="T:FullSerializer.fsMemberSerialization">
            <summary>
            Controls how the reflected converter handles member serialization.
            </summary>
        </member>
        <member name="F:FullSerializer.fsMemberSerialization.OptIn">
            <summary>
            Only members with [SerializeField] or [fsProperty] attributes are serialized.
            </summary>
        </member>
        <member name="F:FullSerializer.fsMemberSerialization.OptOut">
            <summary>
            Only members with [NotSerialized] or [fsIgnore] will not be serialized.
            </summary>
        </member>
        <member name="F:FullSerializer.fsMemberSerialization.Default">
            <summary>
            The default member serialization behavior is applied.
            </summary>
        </member>
        <member name="T:FullSerializer.fsObjectAttribute">
            <summary>
            This attribute controls some serialization behavior for a type. See the comments
            on each of the fields for more information.
            </summary>
        </member>
        <member name="F:FullSerializer.fsObjectAttribute.PreviousModels">
            <summary>
            The previous model that should be used if an old version of this
            object is encountered. Using this attribute also requires that the
            type have a public constructor that takes only one parameter, an object
            instance of the given type. Use of this parameter *requires* that
            the VersionString parameter is also set.
            </summary>
        </member>
        <member name="F:FullSerializer.fsObjectAttribute.VersionString">
            <summary>
            The version string to use for this model. This should be unique among all
            prior versions of this model that is supported for importation. If PreviousModel
            is set, then this attribute must also be set. A good valid example for this
            is "v1", "v2", "v3", ...
            </summary>
        </member>
        <member name="F:FullSerializer.fsObjectAttribute.MemberSerialization">
            <summary>
            This controls the behavior for member serialization.
            The default behavior is fsMemberSerialization.Default.
            </summary>
        </member>
        <member name="F:FullSerializer.fsObjectAttribute.Converter">
            <summary>
            Specify a custom converter to use for serialization. The converter type needs
            to derive from fsBaseConverter. This defaults to null.
            </summary>
        </member>
        <member name="F:FullSerializer.fsObjectAttribute.Processor">
            <summary>
            Specify a custom processor to use during serialization. The processor type needs
            to derive from fsObjectProcessor and the call to CanProcess is not invoked. This
            defaults to null.
            </summary>
        </member>
        <member name="T:FullSerializer.fsObjectProcessor">
            <summary>
            <para>
            Enables injecting code before/after an object has been serialized. This is most
            useful if you want to run the default serialization process but apply a pre/post
            processing step.
            </para>
            <para>
            Multiple object processors can be active at the same time. When running they are
            called in a "nested" fashion - if we have processor1 and process2 added to the
            serializer in that order (p1 then p2), then the execution order will be
            p1#Before p2#Before /serialization/ p2#After p1#After.
            </para>
            </summary>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.CanProcess(System.Type)">
            <summary>
            Is the processor interested in objects of the given type?
            </summary>
            <param name="type">The given type.</param>
            <returns>True if the processor should be applied, false otherwise.</returns>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.OnBeforeSerialize(System.Type,System.Object)">
            <summary>
            Called before serialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="instance">The type of the instance.</param>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.OnAfterSerialize(System.Type,System.Object,FullSerializer.fsData@)">
            <summary>
            Called after serialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="instance">The type of the instance.</param>
            <param name="data">The data that was serialized.</param>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.OnBeforeDeserialize(System.Type,FullSerializer.fsData@)">
            <summary>
            Called before deserialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="data">The data that will be used for deserialization.</param>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.OnBeforeDeserializeAfterInstanceCreation(System.Type,System.Object,FullSerializer.fsData@)">
            <summary>
            Called before deserialization has begun but *after* the object instance has been created. This will get
            invoked even if the user passed in an existing instance.
            </summary>
            <remarks>
            **IMPORTANT**: The actual instance that gets passed here is *not* guaranteed to be an a subtype of storageType, since
            the value for instance is whatever the active converter returned for CreateInstance() - ie, some converters will return
            dummy types in CreateInstance() if instance creation cannot be separated from deserialization (ie, KeyValuePair).
            </remarks>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="instance">The created object instance. No deserialization has been applied to it.</param>
            <param name="data">The data that will be used for deserialization.</param>
        </member>
        <member name="M:FullSerializer.fsObjectProcessor.OnAfterDeserialize(System.Type,System.Object)">
            <summary>
            Called after deserialization.
            </summary>
            <param name="storageType">The field/property type that is storing the instance.</param>
            <param name="instance">The type of the instance.</param>
        </member>
        <member name="T:FullSerializer.fsPropertyAttribute">
            <summary>
            Explicitly mark a property to be serialized. This can also be used to give the name that the
            property should use during serialization.
            </summary>
        </member>
        <member name="F:FullSerializer.fsPropertyAttribute.Name">
            <summary>
            The name of that the property will use in JSON serialization.
            </summary>
        </member>
        <member name="F:FullSerializer.fsPropertyAttribute.Converter">
            <summary>
            Use a custom converter for the given type. Specify the converter to use using typeof.
            </summary>
        </member>
        <member name="T:FullSerializer.fsResult">
            <summary>
            The result of some sort of operation. A result is either successful or not, but if it
            is successful then there may be a set of warnings/messages associated with it. These
            warnings describe the performed error recovery operations.
            </summary>
        </member>
        <member name="F:FullSerializer.fsResult._success">
            <summary>
            Is this result successful?
            </summary>
            <remarks>This is intentionally a `success` state so that when the object
            is default constructed it defaults to a failure state.</remarks>
        </member>
        <member name="F:FullSerializer.fsResult._messages">
            <summary>
            The warning or error messages associated with the result. This may be null if
            there are no messages.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.AddMessage(System.String)">
            <summary>
            Adds a new message to this result.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:FullSerializer.fsResult.AddMessages(FullSerializer.fsResult)">
            <summary>
            Adds only the messages from the other result into this result, ignoring
            the success/failure status of the other result.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.Merge(FullSerializer.fsResult)">
            <summary>
            Merges the other result into this one. If the other result failed, then
            this one too will have failed.
            </summary>
            <remarks>
            Note that you can use += instead of this method so that you don't bury
            the actual method call that is generating the other fsResult.
            </remarks>
        </member>
        <member name="F:FullSerializer.fsResult.Success">
            <summary>
            A successful result.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.Warn(System.String)">
            <summary>
            Create a result that is successful but contains the given warning message.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.Fail(System.String)">
            <summary>
            Create a result that failed.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.op_Addition(FullSerializer.fsResult,FullSerializer.fsResult)">
            <summary>
            Only use this as +=!
            </summary>
        </member>
        <member name="P:FullSerializer.fsResult.Failed">
            <summary>
            Did this result fail? If so, you can see the reasons why in `RawMessages`.
            </summary>
        </member>
        <member name="P:FullSerializer.fsResult.Succeeded">
            <summary>
            Was the result a success? Note that even successful operations may have
            warning messages (`RawMessages`) associated with them.
            </summary>
        </member>
        <member name="P:FullSerializer.fsResult.HasWarnings">
            <summary>
            Does this result have any warnings? This says nothing about if it failed
            or succeeded, just if it has warning messages associated with it.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.AssertSuccess">
            <summary>
            A simply utility method that will assert that this result is successful. If it
            is not, then an exception is thrown.
            </summary>
        </member>
        <member name="M:FullSerializer.fsResult.AssertSuccessWithoutWarnings">
            <summary>
            A simple utility method that will assert that this result is successful and that
            there are no warning messages. This throws an exception if either of those
            asserts are false.
            </summary>
        </member>
        <member name="P:FullSerializer.fsResult.AsException">
            <summary>
            Utility method to convert the result to an exception. This method is only defined
            is `Failed` returns true.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.IsReservedKeyword(System.String)">
            <summary>
            Returns true if the given key is a special keyword that full serializer uses to
            add additional metadata on top of the emitted JSON.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Key_ObjectReference">
            <summary>
            This is an object reference in part of a cyclic graph.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Key_ObjectDefinition">
            <summary>
            This is an object definition, as part of a cyclic graph.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Key_InstanceType">
            <summary>
            This specifies the actual type of an object (the instance type was different from
            the field type).
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Key_Version">
            <summary>
            The version string for the serialized data.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Key_Content">
            <summary>
            If we have to add metadata but the original serialized state was not a dictionary,
            then this will contain the original data.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.StripDeserializationMetadata(FullSerializer.fsData@)">
            <summary>
            Strips all deserialization metadata from the object, like $type and $content fields.
            </summary>
            <remarks>After making this call, you will *not* be able to deserialize the same object instance. The metadata is
            strictly necessary for deserialization!</remarks>
        </member>
        <member name="M:FullSerializer.fsSerializer.ConvertLegacyData(FullSerializer.fsData@)">
            <summary>
            This function converts legacy serialization data into the new format, so that
            the import process can be unified and ignore the old format.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.EnsureDictionary(FullSerializer.fsData)">
            <summary>
            Ensures that the data is a dictionary. If it is not, then it is wrapped inside of one.
            </summary>
        </member>
        <member name="T:FullSerializer.fsSerializer.fsLazyCycleDefinitionWriter">
            <summary>
            This manages instance writing so that we do not write unnecessary $id fields. We
            only need to write out an $id field when there is a corresponding $ref field. This is able
            to write $id references lazily because the fsData instance is not actually written out to text
            until we have entirely finished serializing it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:FullSerializer.fsSerializer._cachedConverterTypeInstances" -->
        <member name="F:FullSerializer.fsSerializer._cachedConverters">
            <summary>
            A cache from type to it's converter.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer._cachedProcessors">
            <summary>
            A cache from type to the set of processors that are interested in it.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer._availableConverters">
            <summary>
            Converters that can be used for type registration.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer._availableDirectConverters">
            <summary>
            Direct converters (optimized _converters). We use these so we don't have to
            perform a scan through every item in _converters and can instead just do an O(1)
            lookup. This is potentially important to perf when there are a ton of direct
            converters.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer._processors">
            <summary>
            Processors that are available.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer._references">
            <summary>
            Reference manager for cycle detection.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Context">
            <summary>
            A context object that fsConverters can use to customize how they operate.
            </summary>
        </member>
        <member name="F:FullSerializer.fsSerializer.Config">
            <summary>
            Configuration options. Also see fsGlobalConfig.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.AddProcessor(FullSerializer.fsObjectProcessor)">
            <summary>
            Add a new processor to the serializer. Multiple processors can run at the same time in the
            same order they were added in.
            </summary>
            <param name="processor">The processor to add.</param>
        </member>
        <member name="M:FullSerializer.fsSerializer.RemoveProcessor``1">
            <summary>
            Remove all processors which derive from TProcessor.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.GetProcessors(System.Type)">
            <summary>
            Fetches all of the processors for the given type.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.AddConverter(FullSerializer.fsBaseConverter)">
            <summary>
            Adds a new converter that can be used to customize how an object is serialized and
            deserialized.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.GetConverter(System.Type,System.Type)">
            <summary>
            Fetches a converter that can serialize/deserialize the given type.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.TrySerialize``1(``0,FullSerializer.fsData@)">
            <summary>
            Helper method that simply forwards the call to TrySerialize(typeof(T), instance, out data);
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.TryDeserialize``1(FullSerializer.fsData,``0@)">
            <summary>
            Generic wrapper around TryDeserialize that simply forwards the call.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.TrySerialize(System.Type,System.Object,FullSerializer.fsData@)">
            <summary>
            Serialize the given value.
            </summary>
            <param name="storageType">The type of field/property that stores the object instance. This is
            important particularly for inheritance, as a field storing an IInterface instance
            should have type information included.</param>
            <param name="instance">The actual object instance to serialize.</param>
            <param name="data">The serialized state of the object.</param>
            <returns>If serialization was successful.</returns>
        </member>
        <member name="M:FullSerializer.fsSerializer.TrySerialize(System.Type,System.Type,System.Object,FullSerializer.fsData@)">
            <summary>
            Serialize the given value.
            </summary>
            <param name="storageType">The type of field/property that stores the object instance. This is
            important particularly for inheritance, as a field storing an IInterface instance
            should have type information included.</param>
            <param name="overrideConverterType">An fsBaseConverter derived type that will be used to serialize
            the object instead of the converter found via the normal discovery mechanisms.</param>
            <param name="instance">The actual object instance to serialize.</param>
            <param name="data">The serialized state of the object.</param>
            <returns>If serialization was successful.</returns>
        </member>
        <member name="M:FullSerializer.fsSerializer.TryDeserialize(FullSerializer.fsData,System.Type,System.Object@)">
            <summary>
            Attempts to deserialize a value from a serialized state.
            </summary>
        </member>
        <member name="M:FullSerializer.fsSerializer.TryDeserialize(FullSerializer.fsData,System.Type,System.Type,System.Object@)">
            <summary>
            Attempts to deserialize a value from a serialized state.
            </summary>
        </member>
        <member name="M:FullSerializer.fsTypeExtensions.CSharpName(System.Type)">
            <summary>
            Returns a pretty name for the type in the style of one that you'd see in C# without the namespace.
            </summary>
        </member>
        <member name="M:FullSerializer.fsTypeExtensions.CSharpName(System.Type,System.Boolean)">
            <summary>
            Returns a pretty name for the type in the style of one that you'd see in C#.
            </summary>
            <parparam name="includeNamespace">Should the name include namespaces?</parparam>
        </member>
        <member name="T:FullSerializer.fsMetaType">
            <summary>
            MetaType contains metadata about a type. This is used by the reflection serializer.
            </summary>
        </member>
        <member name="M:FullSerializer.fsMetaType.ClearCache">
            <summary>
            Clears out the cached type results. Useful if some prior assumptions become invalid, ie, the default member
            serialization mode.
            </summary>
        </member>
        <member name="M:FullSerializer.fsMetaType.CanSerializeProperty(FullSerializer.fsConfig,System.Reflection.PropertyInfo,System.Reflection.MemberInfo[],System.Boolean)">
            <summary>
            Returns if the given property should be serialized.
            </summary>
            <param name="annotationFreeValue">Should a property without any annotations be serialized?</param>
        </member>
        <member name="M:FullSerializer.fsMetaType.EmitAotData">
            <summary>
            Attempt to emit an AOT compiled direct converter for this type.
            </summary>
            <returns>True if AOT data was emitted, false otherwise.</returns>
        </member>
        <member name="P:FullSerializer.fsMetaType.HasDefaultConstructor">
            <summary>
            Returns true if the type represented by this metadata contains a default constructor.
            </summary>
        </member>
        <member name="M:FullSerializer.fsMetaType.CreateInstance">
            <summary>
            Creates a new instance of the type that this metadata points back to. If this type has a
            default constructor, then Activator.CreateInstance will be used to construct the type
            (or Array.CreateInstance if it an array). Otherwise, an uninitialized object created via
            FormatterServices.GetSafeUninitializedObject is used to construct the instance.
            </summary>
        </member>
        <member name="T:DelegateSupport">
            <summary>
            A class that runs delegates using acceleration
            </summary>
        </member>
        <member name="M:DelegateSupport.RegisterActionType``1">
            <summary>
            Registers an action type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterActionType``2">
            <summary>
            Registers an action type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterActionType``4">
            <summary>
            Registers an action type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterActionType``3">
            <summary>
            Registers an action type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterFunctionType``2">
            <summary>
            Registers a function type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterFunctionType``3">
            <summary>
            Registers a function type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterFunctionType``4">
            <summary>
            Registers a function type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.RegisterFunctionType``5">
            <summary>
            Registers a function type for acceleration
            </summary>
            <typeparam name='TType'>
            The type to accelerate
            </typeparam>
        </member>
        <member name="M:DelegateSupport.FastInvoke(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Invokes the method at high speed
            </summary>
            <returns>
            The result of the invocation
            </returns>
            <param name='mi'>
            The method to invoke
            </param>
            <param name='target'>
            The target on which to invoke it
            </param>
            <param name='parameters'>
            The parameters to pass to the method
            </param>
        </member>
        <member name="P:Loom.Current">
             <summary>
             Return the current instance
             </summary>
             <value>
            
             </value>
        </member>
        <member name="M:Loom.QueueOnMainThread(System.Action)">
            <summary>
            Queues an action on the main thread
            </summary>
            <param name='action'>
            The action to execute
            </param>
        </member>
        <member name="M:Loom.QueueOnMainThread(System.Action,System.Single)">
            <summary>
            Queues an action on the main thread after a delay
            </summary>
            <param name='action'>
            The action to run
            </param>
            <param name='time'>
            The amount of time to delay
            </param>
        </member>
        <member name="M:Loom.RunAsync(System.Action)">
            <summary>
            Runs an action on another thread
            </summary>
            <param name='action'>
            The action to execute on another thread
            </param>
        </member>
        <member name="T:MonoBehaviourEx">
            <summary>
            A base class that enables using extended Radical Coroutines
            which allow serialization and resumption of the routines later
            using the standard function prototypes
            </summary>
        </member>
        <member name="M:MonoBehaviourEx.StartCoroutine(System.Collections.IEnumerator)">
            <summary>
            Starts the coroutine in a resumable way
            </summary>
            <returns>
            The RadicalRoutine that enables cancellation etc
            </returns>
            <param name='func'>
            The coroutine to start
            </param>
        </member>
        <member name="M:MonoBehaviourEx.StartCoroutine(System.String)">
            <summary>
            Starts the coroutine in a resumable way
            </summary>
            <returns>
            The RadicalRoutine that enables cancellation etc
            </returns>
            <param name='func'>
            The coroutine to start
            </param>
        </member>
        <member name="M:Radical.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Finds the index of the first occurence of an item in an enumerable.</summary>
            <param name="items">The enumerable to search.</param>
            <param name="item">The item to find.</param>
            <returns>The index of the first matching item, or -1 if the item was not found.</returns>
        </member>
        <member name="M:Radical.FindIndex``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Finds the index of the first item matching an expression in an enumerable.</summary>
            <param name="items">The enumerable to search.</param>
            <param name="predicate">The expression to test the items against.</param>
            <returns>The index of the first matching item, or -1 if no items match.</returns>
        </member>
        <member name="T:CoroutineReturn">
            <summary>
            A waitable coroutine return value
            </summary>
        </member>
        <member name="P:CoroutineReturn.finished">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:CoroutineReturn"/> is finished.
            </summary>
            <value>
            <c>true</c> if finished; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CoroutineReturn.cancel">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:CoroutineReturn"/> is cancelled
            </summary>
            <value>
            <c>true</c> if cancel; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:WaitForAnimation.name">
            <summary>
            Gets the name of the animation
            </summary>
            <value>
            The name.
            </value>
        </member>
        <member name="M:WaitForAnimation.#ctor(UnityEngine.GameObject,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:WaitForAnimation"/> class.
            </summary>
            <param name='go'>
            The game object to run on
            </param>
            <param name='name'>
            The name of the animation to wait for
            </param>
        </member>
        <member name="M:WaitForAnimation.#ctor(UnityEngine.GameObject,System.String,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:WaitForAnimation"/> class.
            </summary>
            <param name='go'>
            The game object to run on
            </param>
            <param name='name'>
            The name of the animation to wait for
            </param>
            <param name='time'>
            The proportion of the animation to wait for
            </param>
        </member>
        <member name="M:WaitForAnimation.#ctor(UnityEngine.GameObject,System.String,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:WaitForAnimation"/> class.
            </summary>
            <param name='go'>
            The game object to run on
            </param>
            <param name='name'>
            The name of the animation to wait for
            </param>
            <param name='time'>
            The proportion of the animation to wait for
            </param>
            <param name='weight'>
            The weight to target
            </param>
        </member>
        <member name="T:INotifyStartStop">
            <summary>
            Interface that notifies a waiting
            coroutine function that it is stopped
            </summary>
        </member>
        <member name="M:INotifyStartStop.Stop">
            <summary>
            This instance has stopped
            </summary>
        </member>
        <member name="M:INotifyStartStop.Start">
            <summary>
            This instance has started
            </summary>
        </member>
        <member name="T:RadicalRoutine">
            <summary>
            A coroutine that can be serialized and
            resumed later
            </summary>
        </member>
        <member name="F:RadicalRoutine.cancel">
            <summary>
            Cancel the coroutine if true
            </summary>
        </member>
        <member name="F:RadicalRoutine.enumerator">
            <summary>
            The enumerator of the running coroutine
            </summary>
        </member>
        <member name="F:RadicalRoutine.Notify">
            <summary>
            The object to notify when completed
            </summary>
        </member>
        <member name="F:RadicalRoutine.Method">
            <summary>
            The method that will be called when
            the routine is complete
            </summary>
        </member>
        <member name="F:RadicalRoutine.finished">
            <summary>
            True when the coroutine is finished
            </summary>
        </member>
        <member name="P:RadicalRoutine.trackedObject">
            <summary>
            Gets or sets the tracked object - which is the object
            that is running the coroutine
            </summary>
            <value>
            The tracked object.
            </value>
        </member>
        <member name="E:RadicalRoutine.Cancelled">
            <summary>
            Event raised if the routine is cancelled
            </summary>
        </member>
        <member name="E:RadicalRoutine.Finished">
            <summary>
            Event raised when the coroutine finished
            </summary>
        </member>
        <member name="M:RadicalRoutine.Cancel">
            <summary>
            Cancel this coroutine
            </summary>
        </member>
        <member name="M:RadicalRoutine.Run(System.Collections.IEnumerator)">
            <summary>
            Run the specified extendedCoRoutine
            </summary>
            <param name='extendedCoRoutine'>
            The coroutine to make serializable
            </param>
        </member>
        <member name="M:RadicalRoutine.Run(System.Collections.IEnumerator,System.String)">
            <summary>
            Run the specified coroutine, invoking a particular method on completion
            </summary>
            <param name='extendedCoRoutine'>
            The coroutine to exten
            </param>
            <param name='methodName'>
            Method to call
            </param>
        </member>
        <member name="M:RadicalRoutine.Create(System.Collections.IEnumerator)">
            <summary>
            Creates a radical coroutine for a specific function
            </summary>
            <param name='extendedCoRoutine'>
            The function to use as a coroutine
            </param>
        </member>
        <member name="M:RadicalRoutine.Run">
            <summary>
            Run this instance.
            </summary>
        </member>
        <member name="M:RadicalRoutine.Run(System.String)">
            <summary>
            Run this instance, calling a method at completion
            </summary>
            <param name='methodName'>
            Method to call
            </param>
        </member>
        <member name="M:RadicalRoutine.Run(System.String,System.Object)">
            <summary>
            Runs the routine calling a method on a target when complete
            </summary>
            <param name='methodName'>
            The method to call
            </param>
            <param name='target'>
            The target object to call it on
            </param>
        </member>
        <member name="T:RadicalRoutineExtensions">
            <summary>
            Radical routine extension class
            </summary>
        </member>
        <member name="M:RadicalRoutineExtensions.StartExtendedCoroutine(UnityEngine.MonoBehaviour,System.Collections.IEnumerator)">
            <summary>
            Starts a coroutine that can be serialized and deserialized
            </summary>
            <returns>
            The running coroutine
            </returns>
            <param name='behaviour'>
            The monobehaviour to start the routine on
            </param>
            <param name='coRoutine'>
            The function to use as a coroutine
            </param>
        </member>
        <member name="M:RadicalRoutineExtensions.StartExtendedCoroutine(UnityEngine.GameObject,System.Collections.IEnumerator)">
            <summary>
            Starts a coroutine that can be serialized and deserialized
            </summary>
            <returns>
            The running coroutine
            </returns>
            <param name='GameObject'>
            The Game Object to start the routine on
            </param>
            <param name='coRoutine'>
            The function to use as a coroutine
            </param>
        </member>
        <member name="M:RadicalRoutineExtensions.StartExtendedCoroutine(UnityEngine.Component,System.Collections.IEnumerator)">
            <summary>
            Starts a coroutine that can be serialized and deserialized
            </summary>
            <returns>
            The running coroutine
            </returns>
            <param name='co'>
            The Component to start the routine on
            </param>
            <param name='coRoutine'>
            The function to use as a coroutine
            </param>
        </member>
        <member name="T:TransformExtensions">
            <summary>
            Helper functions for transforms
            </summary>
        </member>
        <member name="M:TransformExtensions.FirstAncestorOfType``1(UnityEngine.GameObject)">
            <summary>
            Get the first ancestor of a particular type
            </summary>
            <returns>
            The instance of the type or null
            </returns>
            <param name='gameObject'>
            The game object
            </param>
            <typeparam name='T'>
            The type to get
            </typeparam>
        </member>
        <member name="M:TransformExtensions.LastAncestorOfType``1(UnityEngine.GameObject)">
            <summary>
            Get the last ancestor of a particular type
            </summary>
            <returns>
            The instance of the type or null
            </returns>
            <param name='gameObject'>
            The game object
            </param>
            <typeparam name='T'>
            The type to get
            </typeparam>
        </member>
        <member name="M:TransformExtensions.GetAllComponentsInChildren``1(UnityEngine.Transform)">
            <summary>
            Gets components in children, including disabled ones
            </summary>
            <returns>
            An array of the children found
            </returns>
            <param name='parent'>
            The parent to search from
            </param>
            <typeparam name='T'>
            The type to find
            </typeparam>
        </member>
        <member name="M:TransformExtensions.GetAllComponentsInChildren``1(UnityEngine.Component)">
            <summary>
            Gets components in children, including disabled ones
            </summary>
            <returns>
            An array of the children found
            </returns>
            <param name='comp'>
            The parent to search from
            </param>
            <typeparam name='T'>
            The type to find
            </typeparam>
        </member>
        <member name="M:TransformExtensions.GetAllComponentsInChildren``1(UnityEngine.GameObject)">
            <summary>
            Gets components in children, including disabled ones
            </summary>
            <returns>
            An array of the children found
            </returns>
            <param name='go'>
            The parent to search from
            </param>
            <typeparam name='T'>
            The type to find
            </typeparam>
        </member>
        <member name="F:Serialization.Entry.Name">
            <summary>
            The name of the item being read or written
            This should be filled out by the storage when
            MustHaveName = true and deserializing
            </summary>
        </member>
        <member name="F:Serialization.Entry._propertyInfo">
            <summary>
            The type of the item being stored or retrieved
            this should be filled out by the storage when
            MustHaveName=true and deserializing. Will
            be filled in when serializing.
            </summary>
        </member>
        <member name="F:Serialization.Entry.Value">
            <summary>
            On writing, the value of the object for reference, not needed on
            deserialization
            </summary>
        </member>
        <member name="F:Serialization.Entry.IsStatic">
            <summary>
            Indicates whether this entry is static
            </summary>
        </member>
        <member name="F:Serialization.Entry.MustHaveName">
            <summary>
            Set to indicate that the name provided is that of a field or property
            and is needed to reset the value later
            </summary>
        </member>
        <member name="F:Serialization.Entry.OwningType">
            <summary>
            The type of the object which owns the item being serialized or null
            if not directly owned.  This will always be set on serialization and
            deserialization when MustHaveName = true and can be used to
            look up field and property information. Or you can ignore it if
            you don't need it
            </summary>
        </member>
        <member name="P:Serialization.Entry.PropertyInfo">
            <summary>
            The property info or null, if the value did not
            come from a property.  You might want to use
            the to look up attributes attached to the property
            definition
            </summary>
        </member>
        <member name="P:Serialization.Entry.FieldInfo">
            <summary>
            The field info or null, if the value did not
            come from a field. You might want to use it
            to look up attributes attached to the field definition
            </summary>
        </member>
        <member name="F:Serialization.GetWritableAttributes.Vanilla">
            <summary>
            Dictionary of all the used objects to check if properties are different
            to those set during construction
            </summary>
        </member>
        <member name="M:Serialization.IStorage.StartSerializing">
            <summary>
            Starts the serialization process, the serializer should initialize and wait for data
            </summary>
        </member>
        <member name="M:Serialization.IStorage.FinishedSerializing">
            <summary>
            Called when serialization is complete, should return the data or a key
            encoded as a byte array that will be used to reinitialize the serializer
            later
            </summary>
            <returns></returns>
        </member>
        <member name="M:Serialization.IStorage.FinishedDeserializing">
            <summary>
            Called when deserialization is complete, so that resources may be released
            </summary>
        </member>
        <member name="M:Serialization.IStorage.StartSerializing(Serialization.Entry,System.Int32)">
            <summary>
            Called when serializing a new object, the Entry parameter may have MustHaveName set
            when this is true the name must be persisted as is so that the property or field can
            be set when retrieving the data.
            If this routine returns TRUE then no further processing is executed and the object
            is presumed persisted in its entirety
            </summary>
            <returns>Normally FALSE.  True if the object is already fully persisted</returns>
            <param name="entry">The item being serialized</param>
        </member>
        <member name="M:Serialization.IStorage.FinishSerializing(Serialization.Entry)">
            <summary>
            Called when the last information about an object has been written
            </summary>
            <param name="entry">The object being written</param>
        </member>
        <member name="M:Serialization.IStorage.StartDeserializing(Serialization.Entry)">
            <summary>
            Called when deserializing an object.  If the Entry parameter has MustHaveName set then
            the routine should return with the Entry parameter updated with the name and
            the type of the object in StoredType
            If  the storage is capable of fully recreating the object then this routine should return
            the fully constructed object, and no further processing will occur.  Not this does mean
            that it must handle its own references for previously seen objects
            This will be called after DeserializeGetName
            </summary>
            <returns>Normally NULL, it may also return a fully depersisted object</returns>
            <param name="entry"></param>
        </member>
        <member name="M:Serialization.IStorage.DeserializeGetName(Serialization.Entry)">
            <summary>
            Called to allow the storage to retrieve the name of the item being deserialized
            All entries must be named before a call to StartDeserializing, this enables
            the system to fill out the property setter and capture default stored type
            information before deserialization commences
            </summary>
            <param name="entry">The entry whose name should be filled in</param>
        </member>
        <member name="M:Serialization.IStorage.FinishDeserializing(Serialization.Entry)">
            <summary>
            Called when an object has deserialization complete
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:Serialization.IStorage.ShouldWriteFields(Serialization.Entry[])">
            <summary>
            Reads a simple type (or array of bytes) from storage
            </summary>
            <param name="name">The name of the item</param>
            <param name="type">The type to be read</param>
            <returns></returns>
        </member>
        <member name="M:Serialization.BinarySerializer.#ctor">
            <summary>
            Used when serializing
            </summary>
        </member>
        <member name="M:Serialization.BinarySerializer.#ctor(System.Byte[])">
            <summary>
            Used when deserializaing
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Serialization.BinarySerializer.StartDeserializing(Serialization.Entry)">
            <summary>
            Starts to deserialize the object
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="T:Serialization.SerializerId">
            <summary>
              Attribute used to flag IDs this can be useful for check object
              consistence when the serializer is in a mode that does not
              serialize identifiers
            </summary>
        </member>
        <member name="T:Serialization.CreateUsingEvent">
            <summary>
              Always use an event to create instances of this type
            </summary>
        </member>
        <member name="T:Serialization.CreatorFor">
            <summary>
              This class can create a type of object
            </summary>
        </member>
        <member name="T:Serialization.SerializationPriorityAttribute">
            <summary>
              Used to set an order for deserialiation
            </summary>
        </member>
        <member name="T:Serialization.UnitySerializer">
            <summary>
              .NET compatible binary serializer with suppression support
              produces compact representations, suitable for further compression
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.Verbose">
            <summary>
              Write all types, even if they are known, often used with Loud mode
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.StoredTypes">
            <summary>
              Cache for property name to item lookups
            </summary>
        </member>
        <member name="P:Serialization.UnitySerializer.IsChecksum">
            <summary>
              Put the serializer into Checksum mode
            </summary>
        </member>
        <member name="E:Serialization.UnitySerializer.CreateType">
            <summary>
              Event that is fired if a particular type cannot be instantiated
            </summary>
        </member>
        <member name="E:Serialization.UnitySerializer.MapMissingType">
            <summary>
              Event that is fired if a particular type cannot be found
            </summary>
        </member>
        <member name="M:Serialization.UnitySerializer.Deserialize``1(System.Byte[])">
            <summary>
              Deserialize to a type
            </summary>
            <param name="array"> </param>
            <returns> </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.WriteToFile(System.Byte[],System.String)">
            <summary>
            Writes a byte array to a file.
            </summary>
            <param name='data'>
            The bytes to write
            </param>
            <param name='filename'>
            The filename to save them to
            </param>
        </member>
        <member name="M:Serialization.UnitySerializer.WriteToFile(System.String,System.String)">
            <summary>
            Writes a string to file.
            </summary>
            <param name='str'>
            The string to write
            </param>
            <param name='filename'>
            Filename for the output
            </param>/
        </member>
        <member name="M:Serialization.UnitySerializer.Deserialize``1(System.IO.Stream)">
            <summary>
              Deserialize from a stream to a type
            </summary>
            <param name="stream"> </param>
            <returns> </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.GetChecksum(System.Object)">
            <summary>
              Get a checksum for an item.  Checksums "should" be different
              for every object that has a different "meaning".  You can
              flag properties as DoNotChecksum if that helps to keep decorative
              properties away from the checksum whilst including meaningful ones
            </summary>
            <param name="item"> The object to checksum </param>
            <returns> A checksum string, this includes no illegal characters and can be used as a file name </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.RegisterSerializationAssembly">
            <summary>
              Register all of the custom serializers in an assembly
            </summary>
            <param name="assembly"> Leave blank to register the assembly that the method is called from, or pass an assembly </param>
        </member>
        <member name="M:Serialization.UnitySerializer.ScanAllTypesForAttribute(Serialization.UnitySerializer.ScanTypeFunction,System.Reflection.Assembly)">
            <summary>
              Scan all of the types in an assembly for a particular attribute
            </summary>
            <param name="function"> The function to call </param>
            <param name="assembly"> The assembly to scan </param>
        </member>
        <member name="M:Serialization.UnitySerializer.GetPropertyInfo(System.Type)">
            <summary>
              Caches and returns property info for a type
            </summary>
            <param name="itm"> The type that should have its property info returned </param>
            <returns> An enumeration of PropertyInfo objects </returns>
            <remarks>
              It should be noted that the implementation converts the enumeration returned from reflection to an array as this more than double the speed of subsequent reads
            </remarks>
        </member>
        <member name="M:Serialization.UnitySerializer.GetFieldInfo(System.Type)">
            <summary>
              Caches and returns field info for a type
            </summary>
            <param name="itm"> The type that should have its field info returned </param>
            <returns> An enumeration of FieldInfo objects </returns>
            <remarks>
              It should be noted that the implementation converts the enumeration returned from reflection to an array as this more than double the speed of subsequent reads
            </remarks>
        </member>
        <member name="M:Serialization.UnitySerializer.GetPropertyDefinitionId(System.String)">
            <summary>
              Returns a token that represents the name of the property
            </summary>
            <param name="name"> The name for which to return a token </param>
            <returns> A 2 byte token representing the name </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.Deserialize(System.IO.Stream)">
            <summary>
              Deserializes from a stream, potentially into an existing instance
            </summary>
            <param name="inputStream"> Stream to deserialize from </param>
            <param name="instance"> Instance to use </param>
            <returns> </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.Deserialize(System.Byte[])">
            <summary>
              Convert a previously serialized object from a byte array
              back into a .NET object
            </summary>
            <param name="bytes"> The data stream for the object </param>
            <returns> The rehydrated object represented by the data supplied </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeInto(System.Byte[],System.Object)">
            <summary>
              Convert a previously serialized object from a byte array
              back into a .NET object
            </summary>
            <param name="bytes"> The data stream for the object </param>
            <returns> The rehydrated object represented by the data supplied </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.CreateStacks">
            <summary>
              Creates a set of stacks on the current thread
            </summary>
        </member>
        <member name="M:Serialization.UnitySerializer.Serialize(System.Object)">
            <summary>
              Serialize an object into an array of bytes
            </summary>
            <param name="item"> The object to serialize </param>
            <returns> A byte array representation of the item </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.Serialize(System.Object,System.Boolean)">
            <summary>
              Serialize an object into an array of bytes
            </summary>
            <param name="item"> The object to serialize </param>
            <param name="makeVerbose"> Whether the object should be serialized for forwards compatibility </param>
            <returns> A byte array representation of the item </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.IsSimpleType(System.Type)">
            <summary>
              Return whether the type specified is a simple type that can be serialized fast
            </summary>
            <param name="tp"> The type to check </param>
            <returns> True if the type is a simple one and can be serialized directly </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.CreateObject(System.Type)">
            <summary>
              Create an instance of a type
            </summary>
            <param name="itemType"> The type to construct </param>
            <returns> </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.GetTypeId(System.Type)">
            <summary>
              Logs a type and returns a unique token for it
            </summary>
            <param name="tp"> The type to retrieve a token for </param>
            <returns> A 2 byte token representing the type </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.UpdateEntryWithName(Serialization.Entry)">
            <summary>
              Gets a property setter and a standard default type for an entry
            </summary>
            <param name="entry"> </param>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeObject(Serialization.Entry,Serialization.IStorage)">
            <summary>
              Deserializes an object or primitive from the stream
            </summary>
            <param name="entry"> </param>
            <param name="storage"> </param>
            <returns> The value read from the file </returns>
            <remarks>
              The function is supplied with the type of the property that the object was stored in (if known) this enables
              a compact format where types only have to be specified if they differ from the expected one
            </remarks>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeArray(System.Type,Serialization.IStorage,System.Int32,System.Int32)">
            <summary>
              Deserializes an array of values
            </summary>
            <param name="itemType"> The type of the array </param>
            <param name="storage"> </param>
            <param name="count"> </param>
            <returns> The deserialized array </returns>
            <remarks>
              This routine optimizes for arrays of primitives and bytes
            </remarks>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeMultiDimensionArray(System.Type,Serialization.IStorage,System.Int32)">
            <summary>
              Deserializes a multi-dimensional array of values
            </summary>
            <param name="itemType"> The type of the array </param>
            <param name="storage"> </param>
            <param name="objectID"> </param>
            <returns> The deserialized array </returns>
            <remarks>
              This routine deserializes values serialized on a 'row by row' basis, and
              calls into DeserializeArray to do this
            </remarks>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeDictionary(System.Collections.IDictionary,System.Type,Serialization.IStorage)">
            <summary>
              Deserializes a dictionary from storage, handles generic types with storage optimization
            </summary>
            <param name="o"> The newly created dictionary </param>
            <param name="itemType"> The type of the dictionary </param>
            <param name="storage"> </param>
            <returns> The dictionary object updated with the values from storage </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeList(System.Collections.IList,System.Type,Serialization.IStorage)">
            <summary>
              Deserialize a list from the data stream
            </summary>
            <param name="o"> The newly created list </param>
            <param name="itemType"> The type of the list </param>
            <param name="storage"> </param>
            <returns> The list updated with values from the stream </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeObjectAndProperties(System.Object,System.Type,Serialization.IStorage)">
            <summary>
              Deserializes a class based object that is not a collection, looks for both public properties and fields
            </summary>
            <param name="o"> The object being deserialized </param>
            <param name="itemType"> The type of the object </param>
            <param name="storage"> </param>
            <returns> The object updated with values from the stream </returns>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeProperties(Serialization.IStorage,System.Type,System.Object)">
            <summary>
              Deserializes the properties of an object from the stream
            </summary>
            <param name="storage"> </param>
            <param name="itemType"> The type of the object </param>
            <param name="o"> The object to deserialize </param>
        </member>
        <member name="M:Serialization.UnitySerializer.DeserializeFields(Serialization.IStorage,System.Type,System.Object)">
            <summary>
              Deserializes the fields of an object from the stream
            </summary>
            <param name="storage"> </param>
            <param name="itemType"> The type of the object </param>
            <param name="o"> The object to deserialize </param>
        </member>
        <member name="T:Serialization.UnitySerializer.EntryConfiguration">
            <summary>
              Stores configurations for entries
            </summary>
        </member>
        <member name="M:Serialization.UnitySerializer.WriteValue(System.IO.BinaryWriter,System.Object)">
            <summary>
              Write a basic untyped value
            </summary>
            <param name="writer"> The writer to commit byte to </param>
            <param name="value"> The value to write </param>
        </member>
        <member name="M:Serialization.UnitySerializer.ReadValue(System.IO.BinaryReader,System.Type)">
            <summary>
              Read a basic value from the stream
            </summary>
            <param name="reader"> The reader with the stream </param>
            <param name="tp"> The type to read </param>
            <returns> The hydrated value </returns>
        </member>
        <member name="T:Serialization.UnitySerializer.ObjectMappingEventArgs">
            <summary>
              Arguments for object creation event
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.ObjectMappingEventArgs.Instance">
            <summary>
              Supply a type to use instead
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.ObjectMappingEventArgs.TypeToConstruct">
            <summary>
              The type that cannot be
            </summary>
        </member>
        <member name="T:Serialization.UnitySerializer.TypeMappingEventArgs">
            <summary>
              Arguments for a missing type event
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.TypeMappingEventArgs.TypeName">
            <summary>
              The missing types name
            </summary>
        </member>
        <member name="F:Serialization.UnitySerializer.TypeMappingEventArgs.UseType">
            <summary>
              Supply a type to use instead
            </summary>
        </member>
        <member name="T:ComponentSerializerFor">
            <summary>
              Declares a class that serializes a derivation of Component
            </summary>
        </member>
        <member name="M:IComponentSerializer.Serialize(UnityEngine.Component)">
            <summary>
              Serialize the specified component to a byte array
            </summary>
            <param name='component'> Component to be serialized </param>
        </member>
        <member name="M:IComponentSerializer.Deserialize(System.Byte[],UnityEngine.Component)">
            <summary>
              Deserialize the specified data into the instance.
            </summary>
            <param name='data'> The data that represents the component, produced by Serialize </param>
            <param name='instance'> The instance to target </param>
        </member>
        <member name="T:LevelSerializer">
            <summary>
              Level serializer - this class is the main interaction point for
            saving and loading Unity objects and whole scenes.
            </summary>
        </member>
        <member name="T:LevelSerializer.StoreQuery">
            <summary>
            Used when querying if an item should be stored.
            </summary>
        </member>
        <member name="T:LevelSerializer.SerializationModes">
            <summary>
            Serialization modes.
            </summary>
        </member>
        <member name="F:LevelSerializer.SerializationModes.SerializeWhenFree">
            <summary>
            Serialize when suspended
            </summary>
        </member>
        <member name="F:LevelSerializer.SerializationModes.CacheSerialization">
            <summary>
            Ensure that there is serialization data
            when suspending
            </summary>
        </member>
        <member name="F:LevelSerializer.IgnoreTypes">
            <summary>
            The types which should be ignored for serialization
            </summary>
        </member>
        <member name="F:LevelSerializer.PlayerName">
            <summary>
              The name of the player.
            </summary>
        </member>
        <member name="F:LevelSerializer.SaveResumeInformation">
            <summary>
            Whether resume information should be saved when saving the level
            </summary>
        </member>
        <member name="F:LevelSerializer.SerializationMode">
            <summary>
              The serialization caching mode
            </summary>
        </member>
        <member name="F:LevelSerializer.MaxGames">
            <summary>
              The max games that will be stored.
            </summary>
        </member>
        <member name="F:LevelSerializer.SavedGames">
            <summary>
              The saved games.
            </summary>
        </member>
        <member name="F:LevelSerializer.IsDeserializing">
            <summary>
            Indicates whether the system is deserializing a level
            </summary>
        </member>
        <member name="F:LevelSerializer.useCompression">
            <summary>
            Should the system use compression
            </summary>
        </member>
        <member name="M:LevelSerializer.SaveObjectTreeToFile(System.String,UnityEngine.GameObject)">
            <summary>
            Saves a particular object tree to a file.  The file will be
            saved beneath Application.persistentDataPath
            </summary>
            <param name='filename'>
            The filename to save the object tree into
            </param>
            <param name='rootOfTree'>
            The root of the tree
            </param>
        </member>
        <member name="M:LevelSerializer.LoadObjectTreeFromFile(System.String,System.Action{LevelLoader})">
            <summary>
            Loads an object tree into the current scene from a file
            </summary>
            <param name='filename'>
            The file that should be loaded (from within Application.persistentDataPath)
            </param>
            <param name='onComplete'>
            A method call to make when loading is complete
            </param>
        </member>
        <member name="M:LevelSerializer.SerializeLevelToFile(System.String,System.Boolean)">
            <summary>
            Serializes the level to a file
            </summary>
            <param name='filename'>
            The filename to use
            </param>
            <param name="usePersistentDataPath">
            Is filename just a filename in Application.persistentDataPath or a whole path?
            </param>
        </member>
        <member name="M:LevelSerializer.LoadSavedLevelFromFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Loads a level from a file
            </summary>
            <param name='filename'>
            The filename to use
            </param>
            <param name="usePersistentDataPath">
            Is filename just a filename in Application.persistentDataPath or a whole path?
            </param>
            <param name="showGUI">
            Should the screen fade?
            </param>
        </member>
        <member name="M:LevelSerializer.SaveObjectTreeToServer(System.String,UnityEngine.GameObject,System.String,System.String,System.Action{System.Exception})">
            <summary>
            Saves an object tree to a server using POST or STOR
            </summary>
            <param name='uri'>
            The url to save the tree to e.g. ftp://whydoidoit.net/Downloads/someFile.txt
            </param>
            <param name='rootOfTree'>
            The object to be saved
            </param>
            <param name='userName'>
            The user name (if required)
            </param>
            <param name='password'>
            The password (if required)
            </param>
            <param name='onComplete'>
            A function to call when the upload is complete
            </param>
        </member>
        <member name="M:LevelSerializer.LoadObjectTreeFromServer(System.String,System.Action{LevelLoader})">
            <summary>
            Loads an object tree from a server
            </summary>
            <param name='uri'>
            The url to load the object tree from
            </param>
            <param name='onComplete'>
            A method to call when the load is complete
            </param>
        </member>
        <member name="M:LevelSerializer.SerializeLevelToServer(System.String,System.String,System.String,System.Action{System.Exception})">
            <summary>
            Serializes the level to a server.
            </summary>
            <param name='uri'>
            The url of the location for the stored data.  ftp://whydoidoit.net/Downloads/someFile.dat
            </param>
            <param name='userName'>
            User name if required
            </param>
            <param name='password'>
            Password if required
            </param>
            <param name='onComplete'>
            A method to call when the serialization is complete
            </param>
        </member>
        <member name="M:LevelSerializer.LoadSavedLevelFromServer(System.String)">
            <summary>
            Loads the saved level from a server url.
            </summary>
            <param name='uri'>
            The url of the server to load the data from
            </param>
        </member>
        <member name="P:LevelSerializer.CanResume">
            <summary>
            Gets a value indicating whether this instance can resume (there is resume data)
            </summary>
            <value>
            <c>true</c> if this instance can resume; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LevelSerializer.IsSuspended">
            <summary>
              Gets a value indicating whether this instance is suspended.
            </summary>
            <value> <c>true</c> if this instance is suspended; otherwise, <c>false</c> . </value>
        </member>
        <member name="P:LevelSerializer.SuspensionCount">
            <summary>
              Gets the serialization suspension count.
            </summary>
            <value> The suspension count. </value>
        </member>
        <member name="E:LevelSerializer.Deserialized">
            <summary>
              Occurs when the level was deserialized
            </summary>
        </member>
        <member name="E:LevelSerializer.GameSaved">
            <summary>
              Occurs when the level was serialized.
            </summary>
        </member>
        <member name="E:LevelSerializer.SuspendingSerialization">
            <summary>
              Occurs when suspending serialization.
            </summary>
        </member>
        <member name="E:LevelSerializer.ResumingSerialization">
            <summary>
              Occurs when resuming serialization.
            </summary>
        </member>
        <member name="E:LevelSerializer.Store">
            <summary>
            Raised to check whehter a particular item should be stored
            </summary>
        </member>
        <member name="M:LevelSerializer.Resume">
            <summary>
              Resume for a stored game state that wasn't directly saved
            </summary>
        </member>
        <member name="M:LevelSerializer.Checkpoint">
            <summary>
              Create a resumption checkpoint
            </summary>
        </member>
        <member name="M:LevelSerializer.SuspendSerialization">
            <summary>
              Suspends the serialization. Must resume as many times as you suspend
            </summary>
        </member>
        <member name="M:LevelSerializer.ResumeSerialization">
            <summary>
              Resumes the serialization. Must be balanced with calls to SuspendSerialization
            </summary>
        </member>
        <member name="M:LevelSerializer.IgnoreType(System.String)">
            <summary>
              Ignores the type of component when saving games.
            </summary>
            <param name='typename'> Typename of the component to ignore </param>
        </member>
        <member name="M:LevelSerializer.UnIgnoreType(System.String)">
            <summary>
            Remove a type from the ignore list
            </summary>
            <param name='typename'>
            Typename to remove
            </param>
        </member>
        <member name="M:LevelSerializer.IgnoreType(System.Type)">
            <summary>
              Ignores the type of component when saving games.
            </summary>
            <param name='tp'> The type of the component to ignore </param>
        </member>
        <member name="M:LevelSerializer.CreateSaveEntry(System.String,System.Boolean)">
            <summary>
              Creates a saved game for the current position
            </summary>
            <returns> The new save entry. </returns>
            <param name='name'> A name for the save entry </param>
            <param name='urgent'> An urgent save will store the current state, even if suspended. In this case it is likely that clean up will be necessary by handing Deserialized messages or responding to the LevelSerializer.Deserialized event </param>
        </member>
        <member name="M:LevelSerializer.SaveGame(System.String)">
            <summary>
              Saves the game.
            </summary>
            <param name='name'> The name to use for the game </param>
        </member>
        <member name="M:LevelSerializer.SaveDataToFilePrefs">
            <summary>
              Saves the stored game data to player prefs.
            </summary>
        </member>
        <member name="M:LevelSerializer.RegisterAssembly">
            <summary>
              Registers the calling assembly as one providing serialization extensions.
            </summary>
        </member>
        <member name="M:LevelSerializer.AddPrefabPath(System.String)">
            <summary>
              Adds the prefab path.
            </summary>
            <param name='path'> A resource path that contains prefabs to be created for the game </param>
        </member>
        <member name="M:LevelSerializer.DontCollect">
            <summary>
            Dont garbage collect during deserialization
            </summary>
        </member>
        <member name="M:LevelSerializer.Collect">
            <summary>
            Enable garbage collection during deserialization
            </summary>
        </member>
        <member name="P:LevelSerializer.ShouldCollect">
            <summary>
            Gets a value indicating whether this <see cref="T:LevelSerializer"/> should garbage collect.
            </summary>
            <value>
            <c>true</c> if should collect; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:LevelSerializer.SerializeLevel">
            <summary>
              Serializes the level to a string
            </summary>
            <returns> The level data as a string </returns>
            <exception>Is thrown when the serization was suspended
              <cref>SerizationSuspendedException</cref>
            </exception>
        </member>
        <member name="M:LevelSerializer.SerializeLevel(System.Boolean)">
            <summary>
              Serializes the level.
            </summary>
            <returns> The level stored as a string. </returns>
            <param name='urgent'> Whether to ignore an suspension of serialization </param>
            <exception cref='T:LevelSerializer.SerializationSuspendedException'>Is thrown when the serialization was suspended and urgent was not specified</exception>
        </member>
        <member name="M:LevelSerializer.GetComponentsInChildrenWithClause(UnityEngine.GameObject)">
            <summary>
              Internal function
            </summary>
        </member>
        <member name="E:LevelSerializer.Progress">
            <summary>
            Occurs when progress occurs during the deserialization/serialization process
            </summary>
        </member>
        <member name="M:LevelSerializer.SaveObjectTree(UnityEngine.GameObject)">
            <summary>
            Save an objects tree so it can be reloaded later
            </summary>
            <param name="rootOfTree">The object at the root of the tree</param>
            <returns></returns>
        </member>
        <member name="E:LevelSerializer.BeginLoad">
            <summary>
            Occurs before any loading is done.
            </summary>
        </member>
        <member name="M:LevelSerializer.SerializeLevel(System.Boolean,System.String)">
            <summary>
              Serializes the level to a byte array, with an optional root item. The root item
              and its children, if specified, will be the only things saved
            </summary>
            <returns> The level data as a byte array </returns>
            <param name='urgent'> Whether to save even if serialization is suspended </param>
            <param name='id'> Identifier (or null) of an object to be the root of the data serialization </param>
        </member>
        <member name="M:LevelSerializer.LoadObjectTree(System.Byte[],System.Action{LevelLoader})">
            <summary>
            Reload an object tree
            </summary>
            <param name="data">The data for the tree to be loaded</param>
            <param name="onComplete">A function to call when the load is complete</param>
        </member>
        <member name="M:LevelSerializer.LoadSavedLevel(System.String,System.Boolean)">
            <summary>
              Loads the saved level.
            </summary>
            <param name='data'> The data describing the level to load </param>
            <param name="showGUI"> Should the screen fade? </param>
        </member>
        <member name="T:LevelSerializer.LevelData">
            <summary>
            The data stored for a level
            </summary>
        </member>
        <member name="F:LevelSerializer.LevelData.Name">
            <summary>
            The name of the level that was saved
            </summary>
        </member>
        <member name="F:LevelSerializer.LevelData.StoredItems">
            <summary>
            All of the items that were saved
            </summary>
        </member>
        <member name="F:LevelSerializer.LevelData.StoredObjectNames">
            <summary>
            All of the names of items saved
            </summary>
        </member>
        <member name="T:LevelSerializer.SaveEntry">
            <summary>
              A saved game entry
            </summary>
        </member>
        <member name="F:LevelSerializer.SaveEntry.Data">
            <summary>
              The data about the saved game
            </summary>
        </member>
        <member name="F:LevelSerializer.SaveEntry.Level">
            <summary>
              The name of the unity scene
            </summary>
        </member>
        <member name="F:LevelSerializer.SaveEntry.Name">
            <summary>
              The name provided for the saved game.
            </summary>
        </member>
        <member name="F:LevelSerializer.SaveEntry.When">
            <summary>
              The time that the game was saved
            </summary>
        </member>
        <member name="M:LevelSerializer.SaveEntry.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:LevelSerializer.SaveEntry" /> class.
            </summary>
            <param name='contents'> The string representing the data of the saved game (use .ToString()) </param>
        </member>
        <member name="P:LevelSerializer.SaveEntry.Caption">
            <summary>
              Gets the caption.
            </summary>
            <value> The caption which is a combination of the name, the level and the time that the game was saved </value>
        </member>
        <member name="M:LevelSerializer.SaveEntry.Load">
            <summary>
              Load this saved game
            </summary>
        </member>
        <member name="M:LevelSerializer.SaveEntry.Delete">
            <summary>
              Delete this saved game
            </summary>
        </member>
        <member name="M:LevelSerializer.SaveEntry.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents the current <see cref="T:LevelSerializer.SaveEntry" />.
            </summary>
            <returns> A <see cref="T:System.String" /> that represents the current <see cref="T:LevelSerializer.SaveEntry" /> . </returns>
        </member>
        <member name="T:LevelSerializer.SerializationHelper">
            <summary>
              Checks for the ability to serialize
            </summary>
        </member>
        <member name="T:PreWarm">
            <summary>
            This class is used to compress metadata that would otherwise inflate the size of the save files.
            Instead of serializing the complete type and property information, only the index inside these array
            is serialized.
            </summary>
        </member>
        <member name="T:StoreAnimator.LoadingMode">
            <summary>
            Unity's API doesn't allow to restore mecanim transitions. When a save occurs during one,
            you can either choose to revert back to the starting point of the transition or skip it.
            </summary>
        </member>
        <member name="T:StoreAnimator.LayerInfo">
            <summary>
            Stores all relevant information for a mecanim layer
            </summary>
        </member>
        <member name="T:StoreAnimator.ParameterInfo">
            <summary>
            Stores all relevant information for a mecanim parameter
            </summary>
        </member>
        <member name="T:StoreMaterials">
            <summary>
            Used to store material and shader information
            </summary>
        </member>
        <member name="F:StoreMaterials.ShaderDatabase">
            <summary>
            Contains all shaders and properties that are used with all instances of this script in the entire project.
            The initialization happens in the constructor which is created using code generation.
            </summary>
        </member>
        <member name="F:StoreMaterials.cache">
            <summary>
            Caches shaders we already searched for
            </summary>
        </member>
        <member name="P:StoreMaterials.Dirty">
            <summary>
            Stores whether all shaders are in the shader database
            </summary>
        </member>
        <member name="P:StoreMaterials.ShaderCount">
            <summary>
            The amount of shaders in the database
            </summary>
        </member>
        <member name="P:StoreMaterials.PropertyCount">
            <summary>
            The amount of properties of all shaders in the database
            </summary>
        </member>
        <member name="T:StoreMaterials.MaterialProperty">
            <summary>
            Contains a copy of the ShaderPropertyType enum from the ShaderUtil class, because it's not available in player builds
            </summary>
        </member>
        <member name="T:StoreMaterials.StoredValue">
            <summary>
            Container for the stored information
            </summary>
        </member>
        <member name="M:StoreMaterials.GetValues(UnityEngine.Material)">
            <summary>
            Gets the values given a material
            </summary>
            <param name="m">The material</param>
            <returns>A StoredValue containing value and type information</returns>
        </member>
        <member name="M:StoreMaterials.SetValues(UnityEngine.Material,System.Collections.Generic.IEnumerable{StoreMaterials.StoredValue})">
            <summary>
            Restores the material values
            </summary>
            <param name="m">Material</param>
            <param name="values">Set of values</param>
        </member>
        <member name="M:StoreMaterials.GetShaderProperties(UnityEngine.Material)">
            <summary>
            Finds the shader's properties in the shader database and caches them
            </summary>
            <param name="material">Material</param>
            <returns>List of properties</returns>
        </member>
        <member name="T:StoreComponent">
            <summary>
            Store this component when saving data
            </summary>
        </member>
        <member name="T:SerializeGameObjectReference">
            <summary>
            Store a reference to a game object, first checking whether it is really another game
            object and not a prefab
            </summary>
        </member>
        <member name="T:DoNotSerializePublic">
            <summary>
              Indicates that a no public members should be saved by default
            </summary>
        </member>
        <member name="T:SerializeThis">
            <summary>
              Indicates that a property or field should be serialized
            </summary>
        </member>
        <member name="T:DoNotSerialize">
            <summary>
              Indicates that a property or field should not be serialized
            </summary>
        </member>
        <member name="T:DoNotChecksum">
            <summary>
              Used in checksum mode to flag a property as not being part
              of the "meaning" of an object - i.e. two objects with the
              same checksum "mean" the same thing, even if some of the
              properties are different, those properties would not be
              relevant to the purpose of the object
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksums.Adler32">
             <summary>
             Computes Adler32 checksum for a stream of data. An Adler32
             checksum is not as reliable as a CRC32 checksum, but a lot faster to
             compute.
            
             The specification for Adler32 may be found in RFC 1950.
             ZLIB Compressed Data Format Specification version 3.3)
            
            
             From that document:
            
                  "ADLER32 (Adler-32 checksum)
                   This contains a checksum value of the uncompressed data
                   (excluding any dictionary data) computed according to Adler-32
                   algorithm. This algorithm is a 32-bit extension and improvement
                   of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                   standard.
            
                   Adler-32 is composed of two sums accumulated per byte: s1 is
                   the sum of all bytes, s2 is the sum of all s1 values. Both sums
                   are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                   Adler-32 checksum is stored as s2*65536 + s1 in most-
                   significant-byte first (network) order."
            
              "8.2. The Adler-32 algorithm
            
                The Adler-32 algorithm is much faster than the CRC32 algorithm yet
                still provides an extremely low probability of undetected errors.
            
                The modulo on unsigned long accumulators can be delayed for 5552
                bytes, so the modulo operation time is negligible.  If the bytes
                are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
                and order sensitive, unlike the first sum, which is just a
                checksum.  That 65521 is prime is important to avoid a possible
                large class of two-byte errors that leave the check unchanged.
                (The Fletcher checksum uses 255, which is not prime and which also
                makes the Fletcher check insensitive to single byte changes 0 -
                255.)
            
                The sum s1 is initialized to 1 instead of zero to make the length
                of the sequence part of s2, so that the length does not have to be
                checked separately. (Any sequence of zeroes has a Fletcher
                checksum of zero.)"
             </summary>
             <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
             <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Checksums.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksums.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.#ctor">
            <summary>
            Creates a new instance of the Adler32 class.
            The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with a byte value.
            </summary>
            <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with an array of bytes.
            </summary>
            <param name="buffer">
            The source of the data to update with.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            an array of bytes
            </param>
            <param name="offset">
            the start of the data used for this update
            </param>
            <param name="count">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksums.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Checksums.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksums.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksums.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksums.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "value">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksums.StrangeCRC">
            <summary>
            Bzip2 checksum algorithm
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Checksums.StrangeCRC"></see>
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Reset">
            <summary>
            Reset the state of Crc.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Value">
            <summary>
            Get the current Crc value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Int32)">
            <summary>
            Update the Crc value.
            </summary>
            <param name="value">data update is based on</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[])">
            <summary>
            Update Crc based on a block of data
            </summary>
            <param name="buffer">The buffer containing data to update the crc with.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksums.StrangeCRC.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update Crc based on a portion of a block of data
            </summary>
            <param name="buffer">block of data</param>
            <param name="offset">index of first byte to use</param>
            <param name="count">number of bytes to use</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput().
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>
            <returns>Return true if input is needed via <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see>
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch"></param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.prev">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman">
             <summary>
             This is the DeflaterHuffman class.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of Deflate and SetInput.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that all frequencies are zero
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            At least one frequency is non-zero
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending">
             <summary>
             This class stores the pending output of the Deflater.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
            
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream.
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or
            footer.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
             <summary>
             Creates a new inflater.
             </summary>
             <param name="noHeader">
             True if no RFC1950/Zlib header and footer fields are expected in the input data
            
             This is used for GZIPed/Zipped input.
            
             For compatibility with
             Sun JDK you should provide one byte of input more than needed in
             this case.
             </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput().
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterDynHeader.mode">
            <summary>
            The current decode mode
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer">
             <summary>
             This class is general purpose class for writing data to a buffer.
            
             It allows you to write bits as well as bytes
             Based on DeflaterPending.java
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.buffer_">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size in bytes to use when deflating (minimum value 512)
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater.
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close"></see> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.AESAuthCode">
            <summary>
            Returns the 10 byte AUTH CODE to be appended immediately following the AES data stream.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.
            </summary>
            <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given <paramref name="password"/>.
            </summary>
            <param name="password">The password.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to read into.</param>
            <param name="offset">The offset to start storing data at.</param>
            <param name="count">The number of bytes to read</param>
            <param name="callback">The async callback to use.</param>
            <param name="state">The state to use.</param>
            <returns>Returns an <see cref="T:System.IAsyncResult"/></returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="offset">The offset to begin writing at.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> to use.</param>
            <param name="state">The state object.</param>
            <returns>Returns an IAsyncResult.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
            <summary>
            Calls <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buffer_">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="!:ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close"/> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
            <param name="buffer">The buffer to write data from</param>
            <param name="offset">Offset of first byte to write</param>
            <param name="count">The maximum number of bytes to write</param>
            <param name="callback">The method to be called when the asynchronous write operation is completed</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
            <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
            <summary>
            Closes the input stream.  When <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isStreamOwner">
            <summary>
            Flag indicating wether this instance is designated the stream owner.
            When closing if this flag is true the underlying stream is closed.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.UseZip64">
            <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Off">
            <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
            <remarks>An entry can have this overridden if required <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64"></see></remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.On">
            <summary>
            Zip64 should always be used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Dynamic">
            <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.CompressionMethod">
            <summary>
            The kind of compression used for an entry in an archive
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored">
            <summary>
            A direct copy of the file contents is held in the archive
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflate64">
            <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.BZip2">
            <summary>
            BZip2 compression. Not supported by #Zip.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.WinZipAES">
            <summary>
            WinZip special for AES encryption, Now supported by #Zip.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm">
            <summary>
            Identifies the encryption algorithm used for an entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption has been used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.PkzipClassic">
            <summary>
            Encrypted using PKZIP 2.0 or 'classic' encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Des">
            <summary>
            DES encryption has been used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2">
            <summary>
            RCS encryption has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes168">
            <summary>
            Triple DES encryption with 168 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes112">
            <summary>
            Triple DES with 112 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes128">
            <summary>
            AES 128 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes192">
            <summary>
            AES 192 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes256">
            <summary>
            AES 256 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2Corrected">
            <summary>
            RC2 corrected has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Blowfish">
            <summary>
            Blowfish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Twofish">
            <summary>
            Twofish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC4">
            <summary>
            RC4 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Unknown">
            <summary>
            An unknown algorithm has been used for encryption.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set indicates strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress"/>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_MADE_BY">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="!:ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_AES">
            <summary>
            Version indicating AES encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions (4.5 or higher)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTHDR">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENHDR">
            <summary>
            Size of central header entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
            <summary>
            Size of cryptographic header stored before entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCSIG">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANNINGSIG">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANTEMPSIG">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTSIG">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG64">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENDIGITALSIG">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDSIG">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
            <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Dont use unicode encodings if you want to be Zip compatible!
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string.
            </summary>
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[length - 1] converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="flags">The applicable <see cref="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">general purpose bits flags</see></param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.#ctor">
            <summary>
            Initialise default instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">ZipConstants</see>
            </summary>
            <remarks>
            Private to prevent instances being created.
            </remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.HostSystemID">
            <summary>
            Defines known values for the <see cref="T:ICSharpCode.SharpZipLib.Zip.HostSystemID"/> property.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Msdos">
            <summary>
            Host system = MSDOS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Amiga">
            <summary>
            Host system = Amiga
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OpenVms">
            <summary>
            Host system = Open VMS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Unix">
            <summary>
            Host system = Unix
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.VMCms">
            <summary>
            Host system = VMCms
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AtariST">
            <summary>
            Host system = Atari ST
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS2">
            <summary>
            Host system = OS2
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Macintosh">
            <summary>
            Host system = Macintosh
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.ZSystem">
            <summary>
            Host system = ZSystem
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Cpm">
            <summary>
            Host system = Cpm
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WindowsNT">
            <summary>
            Host system = Windows NT
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.MVS">
            <summary>
            Host system = MVS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vse">
            <summary>
            Host system = VSE
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AcornRisc">
            <summary>
            Host system = Acorn RISC
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vfat">
            <summary>
            Host system = VFAT
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AlternateMvs">
            <summary>
            Host system = Alternate MVS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.BeOS">
            <summary>
            Host system = BEOS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Tandem">
            <summary>
            Host system = Tandem
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS400">
            <summary>
            Host system = OS400
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OSX">
            <summary>
            Host system = OSX
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WinZipAES">
            <summary>
            Host system = WinZIP AES
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">
            <summary>
            This class represents an entry in a zip archive.  This can be a file
            or a directory
            ZipFile and ZipInputStream will give you instances of this class as
            information about the members in an archive.  ZipOutputStream
            uses an instance of this class when creating an entry in a Zip file.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
            <summary>
            Creates a zip entry with the given name.
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix' style paths with relative names only.
            There are with no device names and path elements are separated by '/' characters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32)">
            <summary>
            Creates a zip entry with the given name and version required to extract
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix'  style paths with no device names and
            path elements separated by '/' characters.  This is not enforced see <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">CleanName</see>
            on how to ensure names are valid if this is desired.
            </param>
            <param name="versionRequiredToExtract">
            The minimum 'feature version' required this entry
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32,System.Int32,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Initializes an entry with the given name and made by information
            </summary>
            <param name="name">Name for this entry</param>
            <param name="madeByInfo">Version and HostSystem Information</param>
            <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
            <param name="method">Compression method for this entry.</param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            versionRequiredToExtract should be 0 (auto-calculate) or > 10
            </exception>
            <remarks>
            This constructor is used by the ZipFile class when reading from the central header
            It is not generally useful, use the constructor specifying the name only.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Creates a deep copy of the given zip entry.
            </summary>
            <param name="entry">
            The entry to copy.
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasCrc">
            <summary>
            Get a value indicating wether the entry has a CRC value available.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted">
            <summary>
            Get/Set flag indicating if entry is encrypted.
            A simple helper routine to aid interpretation of <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see>
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
            <summary>
            Get / set a flag indicating wether entry name and comment text are
            encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CryptoCheckValue">
            <summary>
            Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">
            <summary>
            Get/Set general purpose bit flag for entry
            </summary>
            <remarks>
            General purpose bit flag<br/>
            <br/>
            Bit 0: If set, indicates the file is encrypted<br/>
            Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
            Imploding:<br/>
            Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
            Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
            <br/>
            Deflating:<br/>
              Bit 2    Bit 1<br/>
                0        0       Normal compression was used<br/>
                0        1       Maximum compression was used<br/>
                1        0       Fast compression was used<br/>
                1        1       Super fast compression was used<br/>
            <br/>
            Bit 3: If set, the fields crc-32, compressed size
            and uncompressed size are were not able to be written during zip file creation
            The correct values are held in a data descriptor immediately following the compressed data. <br/>
            Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
            Bit 5: If set indicates the file contains compressed patch data<br/>
            Bit 6: If set indicates strong encryption was used.<br/>
            Bit 7-10: Unused or reserved<br/>
            Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
            Bit 12-15: Unused or reserved<br/>
            </remarks>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText"></seealso>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
            <summary>
            Get/Set index of this entry in Zip file
            </summary>
            <remarks>This is only valid when the entry is part of a <see cref="!:ZipFile"></see></remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Offset">
            <summary>
            Get/set offset for use in central header
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
            <summary>
            Get/Set external file attributes as an integer.
            The values of this are operating system dependant see
            <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
            <summary>
            Get the version made by for this entry or zero if unknown.
            The value / 10 indicates the major version number, and
            the value mod 10 is the minor version number
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDOSEntry">
            <summary>
            Get a value indicating this entry is for a DOS/Windows system.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasDosAttributes(System.Int32)">
            <summary>
            Test the external attributes for this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"/> to
            see if the external attributes are Dos based (including WINNT and variants)
            and match the values
            </summary>
            <param name="attributes">The attributes to test.</param>
            <returns>Returns true if the external attributes are known to be DOS/Windows
            based and have the same attributes set as the value passed.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">
             <summary>
             Gets the compatability information for the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
             If the external file attributes are compatible with MS-DOS and can be read
             by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
             will be non-zero and identify the host system on which the attributes are compatible.
             </summary>
            
             <remarks>
             The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
             misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
             to obtain up to date and correct information.  The modified appnote by the infozip group is
             particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
             <list type="table">
             <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
             <item>1 - Amiga</item>
             <item>2 - OpenVMS</item>
             <item>3 - Unix</item>
             <item>4 - VM/CMS</item>
             <item>5 - Atari ST</item>
             <item>6 - OS/2 HPFS</item>
             <item>7 - Macintosh</item>
             <item>8 - Z-System</item>
             <item>9 - CP/M</item>
             <item>10 - Windows NTFS</item>
             <item>11 - MVS (OS/390 - Z/OS)</item>
             <item>12 - VSE</item>
             <item>13 - Acorn Risc</item>
             <item>14 - VFAT</item>
             <item>15 - Alternate MVS</item>
             <item>16 - BeOS</item>
             <item>17 - Tandem</item>
             <item>18 - OS/400</item>
             <item>19 - OS/X (Darwin)</item>
             <item>99 - WinZip AES</item>
             <item>remainder - unused</item>
             </list>
             </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version">
            <summary>
            Get minimum Zip feature version required to extract this entry
            </summary>
            <remarks>
            Minimum features are defined as:<br/>
            1.0 - Default value<br/>
            1.1 - File is a volume label<br/>
            2.0 - File is a folder/directory<br/>
            2.0 - File is compressed using Deflate compression<br/>
            2.0 - File is encrypted using traditional encryption<br/>
            2.1 - File is compressed using Deflate64<br/>
            2.5 - File is compressed using PKWARE DCL Implode<br/>
            2.7 - File is a patch data set<br/>
            4.5 - File uses Zip64 format extensions<br/>
            4.6 - File is compressed using BZIP2 compression<br/>
            5.0 - File is encrypted using DES<br/>
            5.0 - File is encrypted using 3DES<br/>
            5.0 - File is encrypted using original RC2 encryption<br/>
            5.0 - File is encrypted using RC4 encryption<br/>
            5.1 - File is encrypted using AES encryption<br/>
            5.1 - File is encrypted using corrected RC2 encryption<br/>
            5.1 - File is encrypted using corrected RC2-64 encryption<br/>
            6.1 - File is encrypted using non-OAEP key wrapping<br/>
            6.2 - Central directory encryption (not confirmed yet)<br/>
            6.3 - File is compressed using LZMA<br/>
            6.3 - File is compressed using PPMD+<br/>
            6.3 - File is encrypted using Blowfish<br/>
            6.3 - File is encrypted using Twofish<br/>
            </remarks>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress">
            <summary>
            Get a value indicating whether this entry can be decompressed by the library.
            </summary>
            <remarks>This is based on the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version"></see> and
            wether the <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64">
            <summary>
            Force this entry to be recorded using Zip64 extensions.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
            <summary>
            Get a value indicating wether Zip64 extensions were forced.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
            <summary>
            Gets a value indicating if the entry requires Zip64 extensions
            to store the full entry values.
            </summary>
            <value>A <see cref="T:System.Boolean"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
            <summary>
            Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime">
            <summary>
            Get/Set DosTime value.
            </summary>
            <remarks>
            The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime">
            <summary>
            Gets/Sets the time of last modification of the entry.
            </summary>
            <remarks>
            The <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Name">
             <summary>
             Returns the entry name.
             </summary>
             <remarks>
             The unix naming convention is followed.
             Path components in the entry should always separated by forward slashes ('/').
             Dos device names like C: should also be removed.
             See the <see cref="!:ZipNameTransform"/> class, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)"/>
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Size">
            <summary>
            Gets/Sets the size of the uncompressed data.
            </summary>
            <returns>
            The size or -1 if unknown.
            </returns>
            <remarks>Setting the size before adding an entry to an archive can help
            avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressedSize">
            <summary>
            Gets/Sets the size of the compressed data.
            </summary>
            <returns>
            The compressed entry size or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Crc">
            <summary>
            Gets/Sets the crc of the uncompressed data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Crc is not in the range 0..0xffffffffL
            </exception>
            <returns>
            The crc value or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">
            <summary>
            Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
            <returns>
            The compression method for this entry
            </returns>
            <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated"/>
            <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored"/>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethodForHeader">
            <summary>
            Gets the compression method for outputting to the local or central header.
            Returns same value as CompressionMethod except when AES encrypting, which
            places 99 in the method and places the real method in the extra data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExtraData">
            <summary>
            Gets/Sets the extra data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Extra data is longer than 64KB (0xffff) bytes.
            </exception>
            <returns>
            Extra data or null if not set.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESKeySize">
            <summary>
            For AES encrypted files returns or sets the number of bits of encryption (128, 192 or 256).
            When setting, only 0 (off), 128 or 256 is supported.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESEncryptionStrength">
            <summary>
            AES Encryption strength for storage in extra data in entry header.
            1 is 128 bit, 2 is 192 bit, 3 is 256 bit.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESSaltLen">
            <summary>
            Returns the length of the salt, in bytes
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESOverheadSize">
            <summary>
            Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ProcessExtraData(System.Boolean)">
            <summary>
            Process extra data fields updating the entry based on the contents.
            </summary>
            <param name="localHeader">True if the extra data fields should be handled
            for a local header, rather than for a central header.
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Comment">
            <summary>
            Gets/Sets the entry comment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If comment is longer than 0xffff.
            </exception>
            <returns>
            The comment or null if not set.
            </returns>
            <remarks>
            A comment is only available for entries when read via the <see cref="!:ZipFile"/> class.
            The <see cref="!:ZipInputStream"/> class doesnt have the comment data available.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDirectory">
            <summary>
            Gets a value indicating if the entry is a directory.
            however.
            </summary>
            <remarks>
            A directory is determined by an entry name with a trailing slash '/'.
            The external file attributes can also indicate an entry is for a directory.
            Currently only dos/windows attributes are tested in this manner.
            The trailing slash convention should always be followed.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsFile">
            <summary>
            Get a value of true if the entry appears to be a file; false otherwise
            </summary>
            <remarks>
            This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
            For linux and others the result may be incorrect.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
            <summary>
            Test entry to see if data can be extracted.
            </summary>
            <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.Clone">
            <summary>
            Creates a copy of this zip entry.
            </summary>
            <returns>An <see cref="T:System.Object"/> that is a copy of the current instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ToString">
            <summary>
            Gets a string representation of this ZipEntry.
            </summary>
            <returns>A readable textual representation of this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"/></returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Test a <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
            supports extracting data compressed with that method
            </summary>
            <param name="method">The compression method to test.</param>
            <returns>Returns true if the compression method is supported; false otherwise</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
            <summary>
            Cleans a name making it conform to Zip file conventions.
            Devices names ('c:\') and UNC share names ('\\server\share') are removed
            and forward slashes ('\') are converted to back slashes ('/').
            Names are made relative by trimming leading slashes which is compatible
            with the ZIP naming convention.
            </summary>
            <param name="name">The name to clean</param>
            <returns>The 'cleaned' name.</returns>
            <remarks>
            The <seealso cref="!:ZipNameTransform">Zip name transform</seealso> class is more flexible.
            </remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">
            <summary>
            ExtraData tagged value interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ITaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the contents of this instance from the data passed.
            </summary>
            <param name="data">The data to extract contents from.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.GetData">
            <summary>
            Get the data representing this instance.
            </summary>
            <returns>Returns the data for this instance.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.RawTaggedData">
            <summary>
            A raw binary tagged value
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.#ctor(System.Int16)">
            <summary>
            Initialise a new instance.
            </summary>
            <param name="tag">The tag ID.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="offset">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.Data">
            <summary>
            Get /set the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.RawTaggedData._tag">
            <summary>
            The tag ID for this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData">
            <summary>
            Class representing extended unix date time values.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">
            <summary>
            Flags indicate which values are included in this instance.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.ModificationTime">
            <summary>
            The modification time is included
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.AccessTime">
            <summary>
            The access time is included
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.CreateTime">
            <summary>
            The create time is included.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.TagID">
            <summary>
            Get the ID
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.ModificationTime">
            <summary>
            Get /set the Modification Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.AccessTime">
            <summary>
            Get / set the Access Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.CreateTime">
            <summary>
            Get / Set the Create Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Include">
            <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.NTTaggedData">
            <summary>
            Class handling NT date time values.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastModificationTime">
            <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.CreateTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">create time</see>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastAccessTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory">
            <summary>
            A factory that creates <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get data for a specific tag value.
            </summary>
            <param name="tag">The tag ID to find.</param>
            <param name="data">The data to search.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
            <returns>The located <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">value found</see>, or null if not found.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipExtraData">
            
             <summary>
             A class to handle the extra data field for Zip entries
             </summary>
             <remarks>
             Extra data contains 0 or more values each prefixed by a header tag and length.
             They contain zero or more bytes of actual data.
             The data is held internally using a copy on write strategy.  This is more efficient but
             means that for extra data created by passing in data can have the values modified by the caller
             in some circumstances.
             </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor">
            <summary>
            Initialise a default instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
            <summary>
            Initialise with known extra data.
            </summary>
            <param name="data">The extra data.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetEntryData">
            <summary>
            Get the raw extra data value
            </summary>
            <returns>Returns the raw byte[] extra data this instance represents.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Clear">
            <summary>
            Clear the stored data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Length">
            <summary>
            Gets the current extra data length.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
            <summary>
            Get a read-only <see cref="T:System.IO.Stream"/> for the associated tag.
            </summary>
            <param name="tag">The tag to locate data for.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> containing tag data or null if no tag was found.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetData(System.Int16)">
            <summary>
            Get the <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
            <param name="tag">The tag to search for.</param>
            <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ValueLength">
            <summary>
            Get the length of the last value found by <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/>
            </summary>
            <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
            <summary>
            Get the index for the current read value.
            </summary>
            <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.
            Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort"/> and <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong"/>. </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.UnreadCount">
            <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
            <summary>
            Find an extra data value
            </summary>
            <param name="headerID">The identifier for the value to find.</param>
            <returns>Returns true if the value was found; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)">
            <summary>
            Add a new entry to extra data.
            </summary>
            <param name="taggedData">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData"/> value to add.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
            <summary>
            Add a new entry to extra data
            </summary>
            <param name="headerID">The ID for this entry.</param>
            <param name="fieldData">The data to add.</param>
            <remarks>If the ID already exists its contents are replaced.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
            <summary>
            Start adding a new entry.
            </summary>
            <remarks>Add data using <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)"/>, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)"/>.
            The new entry is completed and actually added by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)"/></remarks>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
            <summary>
            Add entry data added since <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/> using the ID passed.
            </summary>
            <param name="headerID">The identifier to use for this entry.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
            <summary>
            Add a byte of data to the pending new entry.
            </summary>
            <param name="data">The byte to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
            <summary>
            Add data to a pending new entry.
            </summary>
            <param name="data">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
            <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
            <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
            <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
            <summary>
            Delete an extra data field.
            </summary>
            <param name="headerID">The identifier of the field to delete.</param>
            <returns>Returns true if the field was found and deleted.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong">
            <summary>
            Read a long in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
            <returns>Returns the long value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt">
            <summary>
            Read an integer in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the integer read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort">
            <summary>
            Read a short value in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadByte">
            <summary>
            Read a byte from an extra data
            </summary>
            <returns>The byte value read or -1 if the end of data has been reached.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
            <summary>
            Skip data during reading.
            </summary>
            <param name="amount">The number of bytes to skip.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShortInternal">
            <summary>
            Internal form of <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort"/> that reads data at any location.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.DescriptorData">
            <summary>
            Holds data pertinent to a data descriptor.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.CompressedSize">
            <summary>
            Get /set the compressed size of data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Size">
            <summary>
            Get / set the uncompressed size of data
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Crc">
            <summary>
            Get /set the crc value.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipHelperStream">
            <summary>
            This class assists with writing/reading from Zip files.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.#ctor(System.String)">
            <summary>
            Initialise an instance of this class.
            </summary>
            <param name="name">The name of the file to open.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipHelperStream"/>.
            </summary>
            <param name="stream">The stream to use.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner">
            <summary>
            Get / set a value indicating wether the the underlying stream is owned or not.
            </summary>
            <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            The underlying stream is closed only if <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner"/> is true.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.LocateBlockWithSignature(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            Locates a block with the desired <paramref name="signature"/>.
            </summary>
            <param name="signature">The signature to find.</param>
            <param name="endLocation">Location, marking the end of block.</param>
            <param name="minimumBlockSize">Minimum size of the block.</param>
            <param name="maximumVariableData">The maximum variable data.</param>
            <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteZip64EndOfCentralDirectory(System.Int64,System.Int64,System.Int64)">
            <summary>
            Write Zip64 end of central directory records (File header and locator).
            </summary>
            <param name="noOfEntries">The number of entries in the central directory.</param>
            <param name="sizeEntries">The size of entries in the central directory.</param>
            <param name="centralDirOffset">The offset of the dentral directory.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteEndOfCentralDirectory(System.Int64,System.Int64,System.Int64,System.Byte[])">
            <summary>
            Write the required records to end the central directory.
            </summary>
            <param name="noOfEntries">The number of entries in the directory.</param>
            <param name="sizeEntries">The size of the entries in the directory.</param>
            <param name="startOfCentralDirectory">The start of the central directory.</param>
            <param name="comment">The archive comment.  (This can be null).</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLEShort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLEInt">
            <summary>
            Read an int in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLELong">
            <summary>
            Read a long in little endian byte order.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUshort(System.UInt16)">
            <summary>
            Write a ushort in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUint(System.UInt32)">
            <summary>
            Write a uint in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLELong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUlong(System.UInt64)">
            <summary>
            Write a ulong in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteDataDescriptor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Write a data descriptor.
            </summary>
            <param name="entry">The entry to write a descriptor for.</param>
            <returns>Returns the number of descriptor bytes written.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadDataDescriptor(System.Boolean,ICSharpCode.SharpZipLib.Zip.DescriptorData)">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
            <param name="zip64">if set to <c>true</c> [zip64].</param>
            <param name="data">The data to fill in.</param>
            <returns>Returns the number of bytes read in the descriptor.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassic">
            <summary>
            PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
            While it has been superceded by more recent and more powerful algorithms, its still in use and
            is viable for preventing casual snooping
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
            <summary>
            Generates new encryption keys based on given seed
            </summary>
            <param name="seed">The seed value to initialise keys with.</param>
            <returns>A new key value.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase">
            <summary>
            PkzipClassicCryptoBase provides the low level facilities for encryption
            and decryption using the PkzipClassic algorithm.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.TransformByte">
            <summary>
            Transform a single byte
            </summary>
            <returns>
            The transformed value
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.SetKeys(System.Byte[])">
            <summary>
            Set the key schedule for encryption/decryption.
            </summary>
            <param name="keyData">The data use to set the keys from.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.Reset">
            <summary>
            Reset the internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for encryption.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform"></see>
            </summary>
            <param name="keyBlock">The key block to use.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for decryption.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform"></see>.
            </summary>
            <param name="keyBlock">The key block to decrypt with.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged">
            <summary>
            Defines a wrapper object to access the Pkzip algorithm.
            This class cannot be inherited.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
            <summary>
            Get / set the applicable block size in bits.
            </summary>
            <remarks>The only valid block size is 8.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">key sizes.</see>
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
            <summary>
            Generate an initial vector.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">block sizes</see>.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.Key">
            <summary>
            Get / set the key value applicable.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
            <summary>
            Generate a new random key.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Create an encryptor.
            </summary>
            <param name="rgbKey">The key to use for this encryptor.</param>
            <param name="rgbIV">Initialisation vector for the new encryptor.</param>
            <returns>Returns a new PkzipClassic encryptor</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Create a decryptor.
            </summary>
            <param name="rgbKey">Keys to use for this new decryptor.</param>
            <param name="rgbIV">Initialisation vector for the new decryptor.</param>
            <returns>Returns a new decryptor.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.ZipAESStream">
            <summary>
            Encrypts and decrypts AES ZIP
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Encryption.ZipAESTransform,System.Security.Cryptography.CryptoStreamMode)">
            <summary>
            Constructor
            </summary>
            <param name="stream">The stream on which to perform the cryptographic transformation.</param>
            <param name="transform">Instance of ZipAESTransform</param>
            <param name="mode">Read or Write</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current CryptoStream into buffer,
            and advances the position within the stream by the number of bytes read.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream. </param>
            <param name="offset">The byte offset in buffer at which to begin copying bytes to the current stream. </param>
            <param name="count">The number of bytes to be written to the current stream. </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform">
            <summary>
            Transforms stream using AES in CTR mode
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.#ctor(System.String,System.Byte[],System.Int32,System.Boolean)">
             <summary>
             Constructor.
             </summary>
             <param name="key">Password string</param>
             <param name="saltBytes">Random bytes, length depends on encryption strength.
             128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.</param>
             <param name="blockSize">The encryption strength, in bytes eg 16 for 128 bits.</param>
             <param name="writeMode">True when creating a zip, false when reading. For the AuthCode.</param>
            
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Implement the ICryptoTransform method.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.PwdVerifier">
            <summary>
            Returns the 2 byte password verifier
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.GetAuthCode">
            <summary>
            Returns the 10 byte AUTH CODE to be checked or appended immediately following the AES data stream.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
    </members>
</doc>
