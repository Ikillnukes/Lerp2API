<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ICSharpCode.SharpZipLib.Zip.Compression.Deflater Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_c_sharp_code.html">ICSharpCode</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib.html">SharpZipLib</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip.html">Zip</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html">Compression</a></li><li class="navelem"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html">Deflater</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ICSharpCode.SharpZipLib.Zip.Compression.Deflater Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html" title="This is the Deflater class. The deflater class compresses input with the deflate algorithm described ...">Deflater</a> class. The deflater class compresses input with the deflate algorithm described in RFC 1951. It has several compression levels and three different strategies described below.  
 <a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef92661d02455221261ea607e29710f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aef92661d02455221261ea607e29710f2">Deflater</a> ()</td></tr>
<tr class="memdesc:aef92661d02455221261ea607e29710f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with default compression level.  <a href="#aef92661d02455221261ea607e29710f2">More...</a><br /></td></tr>
<tr class="separator:aef92661d02455221261ea607e29710f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038451ce25b9917398218c5c741e9fb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a038451ce25b9917398218c5c741e9fb2">Deflater</a> (int level)</td></tr>
<tr class="memdesc:a038451ce25b9917398218c5c741e9fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with given compression level.  <a href="#a038451ce25b9917398218c5c741e9fb2">More...</a><br /></td></tr>
<tr class="separator:a038451ce25b9917398218c5c741e9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfca90e822ab3e9984ad3287e95a61a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a8bfca90e822ab3e9984ad3287e95a61a">Deflater</a> (int level, bool noZlibHeaderOrFooter)</td></tr>
<tr class="memdesc:a8bfca90e822ab3e9984ad3287e95a61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with given compression level.  <a href="#a8bfca90e822ab3e9984ad3287e95a61a">More...</a><br /></td></tr>
<tr class="separator:a8bfca90e822ab3e9984ad3287e95a61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a61fe4fb8d97829e1910afbe6fd8be79c">Reset</a> ()</td></tr>
<tr class="memdesc:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before.  <a href="#a61fe4fb8d97829e1910afbe6fd8be79c">More...</a><br /></td></tr>
<tr class="separator:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7b88b7209a07bcd5f69ab94863116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a98a7b88b7209a07bcd5f69ab94863116">Flush</a> ()</td></tr>
<tr class="memdesc:a98a7b88b7209a07bcd5f69ab94863116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun's JDK so I have made it package private. It is used by DeflaterOutputStream to implement flush().  <a href="#a98a7b88b7209a07bcd5f69ab94863116">More...</a><br /></td></tr>
<tr class="separator:a98a7b88b7209a07bcd5f69ab94863116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1b79d68b91057d4044d1d657b81f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c">Finish</a> ()</td></tr>
<tr class="memdesc:a4a1b79d68b91057d4044d1d657b81f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed.  <a href="#a4a1b79d68b91057d4044d1d657b81f6c">More...</a><br /></td></tr>
<tr class="separator:a4a1b79d68b91057d4044d1d657b81f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dd1a3f861adb774c5a31414ad55667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a47dd1a3f861adb774c5a31414ad55667">SetInput</a> (byte[] input)</td></tr>
<tr class="memdesc:a47dd1a3f861adb774c5a31414ad55667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. If you call setInput when needsInput() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needsInput() returns true again. This call is equivalent to  <a href="#a47dd1a3f861adb774c5a31414ad55667">More...</a><br /></td></tr>
<tr class="separator:a47dd1a3f861adb774c5a31414ad55667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b655a78dff6b6fa7374740f63342f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1b655a78dff6b6fa7374740f63342f25">SetInput</a> (byte[] input, int offset, int count)</td></tr>
<tr class="memdesc:a1b655a78dff6b6fa7374740f63342f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. The given byte array should not be changed, before needsInput() returns true again.  <a href="#a1b655a78dff6b6fa7374740f63342f25">More...</a><br /></td></tr>
<tr class="separator:a1b655a78dff6b6fa7374740f63342f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec1f91af74741790108b3af8f877b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e">SetLevel</a> (int level)</td></tr>
<tr class="memdesc:aeec1f91af74741790108b3af8f877b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input.  <a href="#aeec1f91af74741790108b3af8f877b5e">More...</a><br /></td></tr>
<tr class="separator:aeec1f91af74741790108b3af8f877b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d5712ba8aa8a034ee63125d747c71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#af90d5712ba8aa8a034ee63125d747c71">GetLevel</a> ()</td></tr>
<tr class="memdesc:af90d5712ba8aa8a034ee63125d747c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current compression level  <a href="#af90d5712ba8aa8a034ee63125d747c71">More...</a><br /></td></tr>
<tr class="separator:af90d5712ba8aa8a034ee63125d747c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">SetStrategy</a> (<a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html#a922c175879503e6b9e35641deccfbc40">DeflateStrategy</a> strategy)</td></tr>
<tr class="memdesc:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression strategy. Strategy is one of DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED. For the exact position where the strategy is changed, the same as for <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e" title="Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. ">SetLevel()</a> applies.  <a href="#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">More...</a><br /></td></tr>
<tr class="separator:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68958680d1f6cdaef83e705908e5c082"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a68958680d1f6cdaef83e705908e5c082">Deflate</a> (byte[] output)</td></tr>
<tr class="memdesc:a68958680d1f6cdaef83e705908e5c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deflates the current input block with to the given array.  <a href="#a68958680d1f6cdaef83e705908e5c082">More...</a><br /></td></tr>
<tr class="separator:a68958680d1f6cdaef83e705908e5c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611ccb20064abb42667e5cbf7b98c4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1611ccb20064abb42667e5cbf7b98c4a">Deflate</a> (byte[] output, int offset, int length)</td></tr>
<tr class="memdesc:a1611ccb20064abb42667e5cbf7b98c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deflates the current input block to the given array.  <a href="#a1611ccb20064abb42667e5cbf7b98c4a">More...</a><br /></td></tr>
<tr class="separator:a1611ccb20064abb42667e5cbf7b98c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d15527b9581210462405f0d6fc05f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a37d15527b9581210462405f0d6fc05f9">SetDictionary</a> (byte[] dictionary)</td></tr>
<tr class="memdesc:a37d15527b9581210462405f0d6fc05f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dictionary which should be used in the deflate process. This call is equivalent to  <a href="#a37d15527b9581210462405f0d6fc05f9">More...</a><br /></td></tr>
<tr class="separator:a37d15527b9581210462405f0d6fc05f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ef3ee267c15d7a292d6e992c435160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a32ef3ee267c15d7a292d6e992c435160">SetDictionary</a> (byte[] dictionary, int index, int count)</td></tr>
<tr class="memdesc:a32ef3ee267c15d7a292d6e992c435160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again.  <a href="#a32ef3ee267c15d7a292d6e992c435160">More...</a><br /></td></tr>
<tr class="separator:a32ef3ee267c15d7a292d6e992c435160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef92661d02455221261ea607e29710f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aef92661d02455221261ea607e29710f2">Deflater</a> ()</td></tr>
<tr class="memdesc:aef92661d02455221261ea607e29710f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with default compression level.  <a href="#aef92661d02455221261ea607e29710f2">More...</a><br /></td></tr>
<tr class="separator:aef92661d02455221261ea607e29710f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038451ce25b9917398218c5c741e9fb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a038451ce25b9917398218c5c741e9fb2">Deflater</a> (int level)</td></tr>
<tr class="memdesc:a038451ce25b9917398218c5c741e9fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with given compression level.  <a href="#a038451ce25b9917398218c5c741e9fb2">More...</a><br /></td></tr>
<tr class="separator:a038451ce25b9917398218c5c741e9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfca90e822ab3e9984ad3287e95a61a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a8bfca90e822ab3e9984ad3287e95a61a">Deflater</a> (int level, bool noZlibHeaderOrFooter)</td></tr>
<tr class="memdesc:a8bfca90e822ab3e9984ad3287e95a61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new deflater with given compression level.  <a href="#a8bfca90e822ab3e9984ad3287e95a61a">More...</a><br /></td></tr>
<tr class="separator:a8bfca90e822ab3e9984ad3287e95a61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a61fe4fb8d97829e1910afbe6fd8be79c">Reset</a> ()</td></tr>
<tr class="memdesc:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before.  <a href="#a61fe4fb8d97829e1910afbe6fd8be79c">More...</a><br /></td></tr>
<tr class="separator:a61fe4fb8d97829e1910afbe6fd8be79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7b88b7209a07bcd5f69ab94863116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a98a7b88b7209a07bcd5f69ab94863116">Flush</a> ()</td></tr>
<tr class="memdesc:a98a7b88b7209a07bcd5f69ab94863116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun's JDK so I have made it package private. It is used by DeflaterOutputStream to implement flush().  <a href="#a98a7b88b7209a07bcd5f69ab94863116">More...</a><br /></td></tr>
<tr class="separator:a98a7b88b7209a07bcd5f69ab94863116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1b79d68b91057d4044d1d657b81f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c">Finish</a> ()</td></tr>
<tr class="memdesc:a4a1b79d68b91057d4044d1d657b81f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed.  <a href="#a4a1b79d68b91057d4044d1d657b81f6c">More...</a><br /></td></tr>
<tr class="separator:a4a1b79d68b91057d4044d1d657b81f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dd1a3f861adb774c5a31414ad55667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a47dd1a3f861adb774c5a31414ad55667">SetInput</a> (byte[] input)</td></tr>
<tr class="memdesc:a47dd1a3f861adb774c5a31414ad55667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. If you call setInput when needsInput() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needsInput() returns true again. This call is equivalent to  <a href="#a47dd1a3f861adb774c5a31414ad55667">More...</a><br /></td></tr>
<tr class="separator:a47dd1a3f861adb774c5a31414ad55667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b655a78dff6b6fa7374740f63342f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1b655a78dff6b6fa7374740f63342f25">SetInput</a> (byte[] input, int offset, int count)</td></tr>
<tr class="memdesc:a1b655a78dff6b6fa7374740f63342f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. The given byte array should not be changed, before needsInput() returns true again.  <a href="#a1b655a78dff6b6fa7374740f63342f25">More...</a><br /></td></tr>
<tr class="separator:a1b655a78dff6b6fa7374740f63342f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec1f91af74741790108b3af8f877b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e">SetLevel</a> (int level)</td></tr>
<tr class="memdesc:aeec1f91af74741790108b3af8f877b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input.  <a href="#aeec1f91af74741790108b3af8f877b5e">More...</a><br /></td></tr>
<tr class="separator:aeec1f91af74741790108b3af8f877b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d5712ba8aa8a034ee63125d747c71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#af90d5712ba8aa8a034ee63125d747c71">GetLevel</a> ()</td></tr>
<tr class="memdesc:af90d5712ba8aa8a034ee63125d747c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current compression level  <a href="#af90d5712ba8aa8a034ee63125d747c71">More...</a><br /></td></tr>
<tr class="separator:af90d5712ba8aa8a034ee63125d747c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">SetStrategy</a> (<a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html#a922c175879503e6b9e35641deccfbc40">DeflateStrategy</a> strategy)</td></tr>
<tr class="memdesc:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compression strategy. Strategy is one of DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED. For the exact position where the strategy is changed, the same as for <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e" title="Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. ">SetLevel()</a> applies.  <a href="#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">More...</a><br /></td></tr>
<tr class="separator:a1d3cf927ab2a1e6c6a477d9e2d2a1e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68958680d1f6cdaef83e705908e5c082"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a68958680d1f6cdaef83e705908e5c082">Deflate</a> (byte[] output)</td></tr>
<tr class="memdesc:a68958680d1f6cdaef83e705908e5c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deflates the current input block with to the given array.  <a href="#a68958680d1f6cdaef83e705908e5c082">More...</a><br /></td></tr>
<tr class="separator:a68958680d1f6cdaef83e705908e5c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611ccb20064abb42667e5cbf7b98c4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a1611ccb20064abb42667e5cbf7b98c4a">Deflate</a> (byte[] output, int offset, int length)</td></tr>
<tr class="memdesc:a1611ccb20064abb42667e5cbf7b98c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deflates the current input block to the given array.  <a href="#a1611ccb20064abb42667e5cbf7b98c4a">More...</a><br /></td></tr>
<tr class="separator:a1611ccb20064abb42667e5cbf7b98c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d15527b9581210462405f0d6fc05f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a37d15527b9581210462405f0d6fc05f9">SetDictionary</a> (byte[] dictionary)</td></tr>
<tr class="memdesc:a37d15527b9581210462405f0d6fc05f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dictionary which should be used in the deflate process. This call is equivalent to  <a href="#a37d15527b9581210462405f0d6fc05f9">More...</a><br /></td></tr>
<tr class="separator:a37d15527b9581210462405f0d6fc05f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ef3ee267c15d7a292d6e992c435160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a32ef3ee267c15d7a292d6e992c435160">SetDictionary</a> (byte[] dictionary, int index, int count)</td></tr>
<tr class="memdesc:a32ef3ee267c15d7a292d6e992c435160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again.  <a href="#a32ef3ee267c15d7a292d6e992c435160">More...</a><br /></td></tr>
<tr class="separator:a32ef3ee267c15d7a292d6e992c435160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a48bb9f670d4d5783fe8d961c94abc6c5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a48bb9f670d4d5783fe8d961c94abc6c5">BEST_COMPRESSION</a> = 9</td></tr>
<tr class="memdesc:a48bb9f670d4d5783fe8d961c94abc6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The best and slowest compression level. This tries to find very long and distant string repetitions.  <a href="#a48bb9f670d4d5783fe8d961c94abc6c5">More...</a><br /></td></tr>
<tr class="separator:a48bb9f670d4d5783fe8d961c94abc6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdcb79df38a40a31551bf83e136c341"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a2cdcb79df38a40a31551bf83e136c341">BEST_SPEED</a> = 1</td></tr>
<tr class="memdesc:a2cdcb79df38a40a31551bf83e136c341"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worst but fastest compression level.  <a href="#a2cdcb79df38a40a31551bf83e136c341">More...</a><br /></td></tr>
<tr class="separator:a2cdcb79df38a40a31551bf83e136c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b1664d22d2ba8d08620b3ff848063b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a46b1664d22d2ba8d08620b3ff848063b">DEFAULT_COMPRESSION</a> = -1</td></tr>
<tr class="memdesc:a46b1664d22d2ba8d08620b3ff848063b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default compression level.  <a href="#a46b1664d22d2ba8d08620b3ff848063b">More...</a><br /></td></tr>
<tr class="separator:a46b1664d22d2ba8d08620b3ff848063b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbbdacd59167e196eef92c3753b37ff"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a7bbbdacd59167e196eef92c3753b37ff">NO_COMPRESSION</a> = 0</td></tr>
<tr class="memdesc:a7bbbdacd59167e196eef92c3753b37ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This level won't compress at all but output uncompressed blocks.  <a href="#a7bbbdacd59167e196eef92c3753b37ff">More...</a><br /></td></tr>
<tr class="separator:a7bbbdacd59167e196eef92c3753b37ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3465bd16292776ddcf2f5a6fa4c134"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a3d3465bd16292776ddcf2f5a6fa4c134">DEFLATED</a> = 8</td></tr>
<tr class="memdesc:a3d3465bd16292776ddcf2f5a6fa4c134"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compression method. This is the only method supported so far. There is no need to use this constant at all.  <a href="#a3d3465bd16292776ddcf2f5a6fa4c134">More...</a><br /></td></tr>
<tr class="separator:a3d3465bd16292776ddcf2f5a6fa4c134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a074fbfc52ac8f635b64b2c58cd2b3f95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a074fbfc52ac8f635b64b2c58cd2b3f95">Adler</a><code> [get]</code></td></tr>
<tr class="memdesc:a074fbfc52ac8f635b64b2c58cd2b3f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current adler checksum of the data that was processed so far.  <a href="#a074fbfc52ac8f635b64b2c58cd2b3f95">More...</a><br /></td></tr>
<tr class="separator:a074fbfc52ac8f635b64b2c58cd2b3f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4693c429dd0f79c65497f95649da225e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4693c429dd0f79c65497f95649da225e">TotalIn</a><code> [get]</code></td></tr>
<tr class="memdesc:a4693c429dd0f79c65497f95649da225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of input bytes processed so far.  <a href="#a4693c429dd0f79c65497f95649da225e">More...</a><br /></td></tr>
<tr class="separator:a4693c429dd0f79c65497f95649da225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8c55b5c101ba971532affb54f88af"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a5cd8c55b5c101ba971532affb54f88af">TotalOut</a><code> [get]</code></td></tr>
<tr class="memdesc:a5cd8c55b5c101ba971532affb54f88af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of output bytes so far.  <a href="#a5cd8c55b5c101ba971532affb54f88af">More...</a><br /></td></tr>
<tr class="separator:a5cd8c55b5c101ba971532affb54f88af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbabbf940655a8832a8ed57d8804fa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aabbabbf940655a8832a8ed57d8804fa7">IsFinished</a><code> [get]</code></td></tr>
<tr class="memdesc:aabbabbf940655a8832a8ed57d8804fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the stream was finished and no more output bytes are available.  <a href="#aabbabbf940655a8832a8ed57d8804fa7">More...</a><br /></td></tr>
<tr class="separator:aabbabbf940655a8832a8ed57d8804fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8aa7baaad840eb260ff1e0385fe116"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aab8aa7baaad840eb260ff1e0385fe116">IsNeedingInput</a><code> [get]</code></td></tr>
<tr class="memdesc:aab8aa7baaad840eb260ff1e0385fe116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method can also return true when the stream was finished.  <a href="#aab8aa7baaad840eb260ff1e0385fe116">More...</a><br /></td></tr>
<tr class="separator:aab8aa7baaad840eb260ff1e0385fe116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html" title="This is the Deflater class. The deflater class compresses input with the deflate algorithm described ...">Deflater</a> class. The deflater class compresses input with the deflate algorithm described in RFC 1951. It has several compression levels and three different strategies described below. </p>
<p>This class is <em>not</em> thread safe. This is inherent in the API, due to the split of deflate and setInput.</p>
<p>author of the original java version : Jochen Hoenicke </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef92661d02455221261ea607e29710f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef92661d02455221261ea607e29710f2">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with default compression level. </p>

</div>
</div>
<a id="a038451ce25b9917398218c5c741e9fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038451ce25b9917398218c5c741e9fb2">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with given compression level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the compression level, a value between NO_COMPRESSION and BEST_COMPRESSION, or DEFAULT_COMPRESSION. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>if lvl is out of range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bfca90e822ab3e9984ad3287e95a61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfca90e822ab3e9984ad3287e95a61a">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noZlibHeaderOrFooter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with given compression level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the compression level, a value between NO_COMPRESSION and BEST_COMPRESSION. </td></tr>
    <tr><td class="paramname">noZlibHeaderOrFooter</td><td>true, if we should suppress the Zlib/RFC1950 header at the beginning and the adler checksum at the end of the output. This is useful for the GZIP/PKZIP formats. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>if lvl is out of range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef92661d02455221261ea607e29710f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef92661d02455221261ea607e29710f2">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with default compression level. </p>

</div>
</div>
<a id="a038451ce25b9917398218c5c741e9fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038451ce25b9917398218c5c741e9fb2">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with given compression level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the compression level, a value between NO_COMPRESSION and BEST_COMPRESSION, or DEFAULT_COMPRESSION. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>if lvl is out of range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bfca90e822ab3e9984ad3287e95a61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfca90e822ab3e9984ad3287e95a61a">&#9670;&nbsp;</a></span>Deflater() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noZlibHeaderOrFooter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new deflater with given compression level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the compression level, a value between NO_COMPRESSION and BEST_COMPRESSION. </td></tr>
    <tr><td class="paramname">noZlibHeaderOrFooter</td><td>true, if we should suppress the Zlib/RFC1950 header at the beginning and the adler checksum at the end of the output. This is useful for the GZIP/PKZIP formats. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>if lvl is out of range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68958680d1f6cdaef83e705908e5c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68958680d1f6cdaef83e705908e5c082">&#9670;&nbsp;</a></span>Deflate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deflates the current input block with to the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The buffer where compressed data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of compressed bytes added to the output, or 0 if either <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aab8aa7baaad840eb260ff1e0385fe116" title="Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method can al...">IsNeedingInput()</a> or IsFinished returns true or length is zero. </dd></dl>

</div>
</div>
<a id="a1611ccb20064abb42667e5cbf7b98c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611ccb20064abb42667e5cbf7b98c4a">&#9670;&nbsp;</a></span>Deflate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deflates the current input block to the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Buffer to store the compressed data. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the output array. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes that may be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of compressed bytes added to the output, or 0 if either needsInput() or finished() returns true or length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>If <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c" title="Finishes the deflater with the current input block. It is an error to give more input after this meth...">Finish()</a> was previously called. </td></tr>
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>If offset or length don't match the array length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68958680d1f6cdaef83e705908e5c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68958680d1f6cdaef83e705908e5c082">&#9670;&nbsp;</a></span>Deflate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deflates the current input block with to the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The buffer where compressed data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of compressed bytes added to the output, or 0 if either <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aab8aa7baaad840eb260ff1e0385fe116" title="Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method can al...">IsNeedingInput()</a> or IsFinished returns true or length is zero. </dd></dl>

</div>
</div>
<a id="a1611ccb20064abb42667e5cbf7b98c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611ccb20064abb42667e5cbf7b98c4a">&#9670;&nbsp;</a></span>Deflate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deflates the current input block to the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Buffer to store the compressed data. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the output array. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes that may be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of compressed bytes added to the output, or 0 if either needsInput() or finished() returns true or length is zero. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>If <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c" title="Finishes the deflater with the current input block. It is an error to give more input after this meth...">Finish()</a> was previously called. </td></tr>
    <tr><td class="paramname">System.ArgumentOutOfRangeException</td><td>If offset or length don't match the array length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1b79d68b91057d4044d1d657b81f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1b79d68b91057d4044d1d657b81f6c">&#9670;&nbsp;</a></span>Finish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. </p>

</div>
</div>
<a id="a4a1b79d68b91057d4044d1d657b81f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1b79d68b91057d4044d1d657b81f6c">&#9670;&nbsp;</a></span>Finish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. </p>

</div>
</div>
<a id="a98a7b88b7209a07bcd5f69ab94863116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a7b88b7209a07bcd5f69ab94863116">&#9670;&nbsp;</a></span>Flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun's JDK so I have made it package private. It is used by DeflaterOutputStream to implement flush(). </p>

</div>
</div>
<a id="a98a7b88b7209a07bcd5f69ab94863116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a7b88b7209a07bcd5f69ab94863116">&#9670;&nbsp;</a></span>Flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun's JDK so I have made it package private. It is used by DeflaterOutputStream to implement flush(). </p>

</div>
</div>
<a id="af90d5712ba8aa8a034ee63125d747c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90d5712ba8aa8a034ee63125d747c71">&#9670;&nbsp;</a></span>GetLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current compression level </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current compression level</dd></dl>

</div>
</div>
<a id="af90d5712ba8aa8a034ee63125d747c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90d5712ba8aa8a034ee63125d747c71">&#9670;&nbsp;</a></span>GetLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current compression level </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current compression level</dd></dl>

</div>
</div>
<a id="a61fe4fb8d97829e1910afbe6fd8be79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fe4fb8d97829e1910afbe6fd8be79c">&#9670;&nbsp;</a></span>Reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. </p>

</div>
</div>
<a id="a61fe4fb8d97829e1910afbe6fd8be79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fe4fb8d97829e1910afbe6fd8be79c">&#9670;&nbsp;</a></span>Reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. </p>

</div>
</div>
<a id="a37d15527b9581210462405f0d6fc05f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d15527b9581210462405f0d6fc05f9">&#9670;&nbsp;</a></span>SetDictionary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dictionary which should be used in the deflate process. This call is equivalent to </p>
<p><code>setDictionary(dict, 0, dict.Length)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if SetInput () or Deflate () were already called or another dictionary was already set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ef3ee267c15d7a292d6e992c435160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ef3ee267c15d7a292d6e992c435160">&#9670;&nbsp;</a></span>SetDictionary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The dictionary data </td></tr>
    <tr><td class="paramname">index</td><td>The index where dictionary information commences. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes in the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>If SetInput () or <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a68958680d1f6cdaef83e705908e5c082" title="Deflates the current input block with to the given array. ">Deflate()</a> were already called or another dictionary was already set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d15527b9581210462405f0d6fc05f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d15527b9581210462405f0d6fc05f9">&#9670;&nbsp;</a></span>SetDictionary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dictionary which should be used in the deflate process. This call is equivalent to </p>
<p><code>setDictionary(dict, 0, dict.Length)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if SetInput () or Deflate () were already called or another dictionary was already set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ef3ee267c15d7a292d6e992c435160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ef3ee267c15d7a292d6e992c435160">&#9670;&nbsp;</a></span>SetDictionary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dictionary</td><td>The dictionary data </td></tr>
    <tr><td class="paramname">index</td><td>The index where dictionary information commences. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes in the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>If SetInput () or <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a68958680d1f6cdaef83e705908e5c082" title="Deflates the current input block with to the given array. ">Deflate()</a> were already called or another dictionary was already set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47dd1a3f861adb774c5a31414ad55667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dd1a3f861adb774c5a31414ad55667">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. If you call setInput when needsInput() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needsInput() returns true again. This call is equivalent to </p>
<p><code>setInput(input, 0, input.length)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the buffer containing the input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if the buffer was finished() or ended(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47dd1a3f861adb774c5a31414ad55667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dd1a3f861adb774c5a31414ad55667">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. If you call setInput when needsInput() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needsInput() returns true again. This call is equivalent to </p>
<p><code>setInput(input, 0, input.length)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the buffer containing the input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if the buffer was finished() or ended(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b655a78dff6b6fa7374740f63342f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b655a78dff6b6fa7374740f63342f25">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. The given byte array should not be changed, before needsInput() returns true again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the buffer containing the input data. </td></tr>
    <tr><td class="paramname">offset</td><td>the start of the data. </td></tr>
    <tr><td class="paramname">count</td><td>the number of data bytes of input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if the buffer was <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c" title="Finishes the deflater with the current input block. It is an error to give more input after this meth...">Finish()</a>ed or if previous input is still pending. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b655a78dff6b6fa7374740f63342f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b655a78dff6b6fa7374740f63342f25">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data which should be compressed next. This should be only called when needsInput indicates that more input is needed. The given byte array should not be changed, before needsInput() returns true again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the buffer containing the input data. </td></tr>
    <tr><td class="paramname">offset</td><td>the start of the data. </td></tr>
    <tr><td class="paramname">count</td><td>the number of data bytes of input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System.InvalidOperationException</td><td>if the buffer was <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#a4a1b79d68b91057d4044d1d657b81f6c" title="Finishes the deflater with the current input block. It is an error to give more input after this meth...">Finish()</a>ed or if previous input is still pending. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeec1f91af74741790108b3af8f877b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1f91af74741790108b3af8f877b5e">&#9670;&nbsp;</a></span>SetLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the new compression level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeec1f91af74741790108b3af8f877b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1f91af74741790108b3af8f877b5e">&#9670;&nbsp;</a></span>SetLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the new compression level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3cf927ab2a1e6c6a477d9e2d2a1e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">&#9670;&nbsp;</a></span>SetStrategy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html#a922c175879503e6b9e35641deccfbc40">DeflateStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the compression strategy. Strategy is one of DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED. For the exact position where the strategy is changed, the same as for <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e" title="Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. ">SetLevel()</a> applies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The new compression strategy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3cf927ab2a1e6c6a477d9e2d2a1e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3cf927ab2a1e6c6a477d9e2d2a1e93">&#9670;&nbsp;</a></span>SetStrategy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html#a922c175879503e6b9e35641deccfbc40">DeflateStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the compression strategy. Strategy is one of DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED. For the exact position where the strategy is changed, the same as for <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater.html#aeec1f91af74741790108b3af8f877b5e" title="Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needsInput is true the change of compression level will occur somewhere near before the end of the so far given input. ">SetLevel()</a> applies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The new compression strategy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a48bb9f670d4d5783fe8d961c94abc6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bb9f670d4d5783fe8d961c94abc6c5">&#9670;&nbsp;</a></span>BEST_COMPRESSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The best and slowest compression level. This tries to find very long and distant string repetitions. </p>

</div>
</div>
<a id="a2cdcb79df38a40a31551bf83e136c341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdcb79df38a40a31551bf83e136c341">&#9670;&nbsp;</a></span>BEST_SPEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The worst but fastest compression level. </p>

</div>
</div>
<a id="a46b1664d22d2ba8d08620b3ff848063b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b1664d22d2ba8d08620b3ff848063b">&#9670;&nbsp;</a></span>DEFAULT_COMPRESSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default compression level. </p>

</div>
</div>
<a id="a3d3465bd16292776ddcf2f5a6fa4c134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3465bd16292776ddcf2f5a6fa4c134">&#9670;&nbsp;</a></span>DEFLATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFLATED = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compression method. This is the only method supported so far. There is no need to use this constant at all. </p>

</div>
</div>
<a id="a7bbbdacd59167e196eef92c3753b37ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbbdacd59167e196eef92c3753b37ff">&#9670;&nbsp;</a></span>NO_COMPRESSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This level won't compress at all but output uncompressed blocks. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a074fbfc52ac8f635b64b2c58cd2b3f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074fbfc52ac8f635b64b2c58cd2b3f95">&#9670;&nbsp;</a></span>Adler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Adler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current adler checksum of the data that was processed so far. </p>

</div>
</div>
<a id="aabbabbf940655a8832a8ed57d8804fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbabbf940655a8832a8ed57d8804fa7">&#9670;&nbsp;</a></span>IsFinished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsFinished</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the stream was finished and no more output bytes are available. </p>

</div>
</div>
<a id="aab8aa7baaad840eb260ff1e0385fe116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8aa7baaad840eb260ff1e0385fe116">&#9670;&nbsp;</a></span>IsNeedingInput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the input buffer is empty. You should then call setInput(). NOTE: This method can also return true when the stream was finished. </p>

</div>
</div>
<a id="a4693c429dd0f79c65497f95649da225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4693c429dd0f79c65497f95649da225e">&#9670;&nbsp;</a></span>TotalIn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalIn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of input bytes processed so far. </p>

</div>
</div>
<a id="a5cd8c55b5c101ba971532affb54f88af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd8c55b5c101ba971532affb54f88af">&#9670;&nbsp;</a></span>TotalOut</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of output bytes so far. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Project/Utility/SharpZIP/src/Zip/Compression/Deflater.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
