<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ICSharpCode.SharpZipLib.Tar.TarOutputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_c_sharp_code.html">ICSharpCode</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib.html">SharpZipLib</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar.html">Tar</a></li><li class="navelem"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html">TarOutputStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ICSharpCode.SharpZipLib.Tar.TarOutputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write().  
 <a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ICSharpCode.SharpZipLib.Tar.TarOutputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.png" usemap="#ICSharpCode.SharpZipLib.Tar.TarOutputStream_map" alt=""/>
  <map id="ICSharpCode.SharpZipLib.Tar.TarOutputStream_map" name="ICSharpCode.SharpZipLib.Tar.TarOutputStream_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c324e179a9735fd0c3c128bbc704c7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a9c324e179a9735fd0c3c128bbc704c7c">TarOutputStream</a> (Stream <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a521e429618eb86a1a31242ec2d8e92b0">outputStream</a>)</td></tr>
<tr class="memdesc:a9c324e179a9735fd0c3c128bbc704c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> using default block factor  <a href="#a9c324e179a9735fd0c3c128bbc704c7c">More...</a><br /></td></tr>
<tr class="separator:a9c324e179a9735fd0c3c128bbc704c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7670065482af0ce4f4be9c0d588a15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#abb7670065482af0ce4f4be9c0d588a15">TarOutputStream</a> (Stream <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a521e429618eb86a1a31242ec2d8e92b0">outputStream</a>, int blockFactor)</td></tr>
<tr class="memdesc:abb7670065482af0ce4f4be9c0d588a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> with user specified block factor  <a href="#abb7670065482af0ce4f4be9c0d588a15">More...</a><br /></td></tr>
<tr class="separator:abb7670065482af0ce4f4be9c0d588a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c48071309528497f553f5b015503802"><td class="memItemLeft" align="right" valign="top">override long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a2c48071309528497f553f5b015503802">Seek</a> (long offset, SeekOrigin origin)</td></tr>
<tr class="memdesc:a2c48071309528497f553f5b015503802"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the position within the current stream  <a href="#a2c48071309528497f553f5b015503802">More...</a><br /></td></tr>
<tr class="separator:a2c48071309528497f553f5b015503802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc151653b44969093b2cfb6fd4cd6048"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#adc151653b44969093b2cfb6fd4cd6048">SetLength</a> (long value)</td></tr>
<tr class="memdesc:adc151653b44969093b2cfb6fd4cd6048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length of the current stream  <a href="#adc151653b44969093b2cfb6fd4cd6048">More...</a><br /></td></tr>
<tr class="separator:adc151653b44969093b2cfb6fd4cd6048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c252230a5bc39942e0417219dd732e6"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a3c252230a5bc39942e0417219dd732e6">ReadByte</a> ()</td></tr>
<tr class="memdesc:a3c252230a5bc39942e0417219dd732e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from the stream and advance the position within the stream by one byte or returns -1 if at the end of the stream.  <a href="#a3c252230a5bc39942e0417219dd732e6">More...</a><br /></td></tr>
<tr class="separator:a3c252230a5bc39942e0417219dd732e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ff99bd6bbb5900972616c0df73b62d"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a81ff99bd6bbb5900972616c0df73b62d">Read</a> (byte[] <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a5c3ade1fecb25c00a1e17af46cac1e0b">buffer</a>, int offset, int count)</td></tr>
<tr class="memdesc:a81ff99bd6bbb5900972616c0df73b62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">read bytes from the current stream and advance the position within the stream by the number of bytes read.  <a href="#a81ff99bd6bbb5900972616c0df73b62d">More...</a><br /></td></tr>
<tr class="separator:a81ff99bd6bbb5900972616c0df73b62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477e87e93e590aecbf41527d8e1e8222"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a477e87e93e590aecbf41527d8e1e8222">Flush</a> ()</td></tr>
<tr class="memdesc:a477e87e93e590aecbf41527d8e1e8222"><td class="mdescLeft">&#160;</td><td class="mdescRight">All buffered data is written to destination  <a href="#a477e87e93e590aecbf41527d8e1e8222">More...</a><br /></td></tr>
<tr class="separator:a477e87e93e590aecbf41527d8e1e8222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35766aed4ddf363bbaca72d33b0e071d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a35766aed4ddf363bbaca72d33b0e071d">Finish</a> ()</td></tr>
<tr class="memdesc:a35766aed4ddf363bbaca72d33b0e071d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the TAR archive without closing the underlying OutputStream. The result is that the EOF block of nulls is written.  <a href="#a35766aed4ddf363bbaca72d33b0e071d">More...</a><br /></td></tr>
<tr class="separator:a35766aed4ddf363bbaca72d33b0e071d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab744534cafac308f51f6586f06ca3d86"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#ab744534cafac308f51f6586f06ca3d86">Close</a> ()</td></tr>
<tr class="memdesc:ab744534cafac308f51f6586f06ca3d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the TAR archive and closes the underlying OutputStream.  <a href="#ab744534cafac308f51f6586f06ca3d86">More...</a><br /></td></tr>
<tr class="separator:ab744534cafac308f51f6586f06ca3d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3883f68913041868a45f1f257f490b8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a3883f68913041868a45f1f257f490b8f">GetRecordSize</a> ()</td></tr>
<tr class="memdesc:a3883f68913041868a45f1f257f490b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the record size being used by this stream's <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>.  <a href="#a3883f68913041868a45f1f257f490b8f">More...</a><br /></td></tr>
<tr class="separator:a3883f68913041868a45f1f257f490b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0a70f8fb770a0be04b69944170c2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a0d0a70f8fb770a0be04b69944170c2db">PutNextEntry</a> (<a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_entry.html">TarEntry</a> entry)</td></tr>
<tr class="memdesc:a0d0a70f8fb770a0be04b69944170c2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an entry on the output stream. This writes the entry's header and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry's contents. Once the contents are written, closeEntry() <b>MUST</b> be called to ensure that all buffered data is completely written to the output stream.  <a href="#a0d0a70f8fb770a0be04b69944170c2db">More...</a><br /></td></tr>
<tr class="separator:a0d0a70f8fb770a0be04b69944170c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ddc3a9e0219c85e900de5deb0cf74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a655ddc3a9e0219c85e900de5deb0cf74">CloseEntry</a> ()</td></tr>
<tr class="memdesc:a655ddc3a9e0219c85e900de5deb0cf74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an entry. This method MUST be called for all file entries that contain data. The reason is that we must buffer data written to the stream in order to satisfy the buffer's block based writes. Thus, there may be data fragments still being assembled that must be written to the output stream before this entry is closed and the next entry written.  <a href="#a655ddc3a9e0219c85e900de5deb0cf74">More...</a><br /></td></tr>
<tr class="separator:a655ddc3a9e0219c85e900de5deb0cf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a5cb90ae7900e926e78a299cf53893"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a86a5cb90ae7900e926e78a299cf53893">WriteByte</a> (byte value)</td></tr>
<tr class="memdesc:a86a5cb90ae7900e926e78a299cf53893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte to the current tar archive entry. This method simply calls Write(byte[], int, int).  <a href="#a86a5cb90ae7900e926e78a299cf53893">More...</a><br /></td></tr>
<tr class="separator:a86a5cb90ae7900e926e78a299cf53893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0099fc6688112932356222e4aa16c9"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a6b0099fc6688112932356222e4aa16c9">Write</a> (byte[] <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a5c3ade1fecb25c00a1e17af46cac1e0b">buffer</a>, int offset, int count)</td></tr>
<tr class="memdesc:a6b0099fc6688112932356222e4aa16c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.  <a href="#a6b0099fc6688112932356222e4aa16c9">More...</a><br /></td></tr>
<tr class="separator:a6b0099fc6688112932356222e4aa16c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abe4e3aeed770f72702cfdf299afc56cf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#abe4e3aeed770f72702cfdf299afc56cf">currSize</a></td></tr>
<tr class="memdesc:abe4e3aeed770f72702cfdf299afc56cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size for the current entry  <a href="#abe4e3aeed770f72702cfdf299afc56cf">More...</a><br /></td></tr>
<tr class="separator:abe4e3aeed770f72702cfdf299afc56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7fe07d3fe24316c6b3d85471897c66"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#aaa7fe07d3fe24316c6b3d85471897c66">blockBuffer</a></td></tr>
<tr class="memdesc:aaa7fe07d3fe24316c6b3d85471897c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">single block working buffer  <a href="#aaa7fe07d3fe24316c6b3d85471897c66">More...</a><br /></td></tr>
<tr class="separator:aaa7fe07d3fe24316c6b3d85471897c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9684b64869d1db25f3b8ff15f160c6"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a9a9684b64869d1db25f3b8ff15f160c6">assemblyBuffer</a></td></tr>
<tr class="memdesc:a9a9684b64869d1db25f3b8ff15f160c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Assembly' buffer used to assemble data before writing  <a href="#a9a9684b64869d1db25f3b8ff15f160c6">More...</a><br /></td></tr>
<tr class="separator:a9a9684b64869d1db25f3b8ff15f160c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3ade1fecb25c00a1e17af46cac1e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html">TarBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a5c3ade1fecb25c00a1e17af46cac1e0b">buffer</a></td></tr>
<tr class="memdesc:a5c3ade1fecb25c00a1e17af46cac1e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a> used to provide correct blocking factor  <a href="#a5c3ade1fecb25c00a1e17af46cac1e0b">More...</a><br /></td></tr>
<tr class="separator:a5c3ade1fecb25c00a1e17af46cac1e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521e429618eb86a1a31242ec2d8e92b0"><td class="memItemLeft" align="right" valign="top">Stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a521e429618eb86a1a31242ec2d8e92b0">outputStream</a></td></tr>
<tr class="memdesc:a521e429618eb86a1a31242ec2d8e92b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the destination stream for the archive contents  <a href="#a521e429618eb86a1a31242ec2d8e92b0">More...</a><br /></td></tr>
<tr class="separator:a521e429618eb86a1a31242ec2d8e92b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a5d30d12b3c98a5b45d17b54291e8b50d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a5d30d12b3c98a5b45d17b54291e8b50d">IsStreamOwner</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a5d30d12b3c98a5b45d17b54291e8b50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get/set flag indicating ownership of the underlying stream. When the flag is true <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#ab744534cafac308f51f6586f06ca3d86">Close</a> will close the underlying stream also.  <a href="#a5d30d12b3c98a5b45d17b54291e8b50d">More...</a><br /></td></tr>
<tr class="separator:a5d30d12b3c98a5b45d17b54291e8b50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba911bf812fc9917b0848f3632a14b83"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#aba911bf812fc9917b0848f3632a14b83">CanRead</a><code> [get]</code></td></tr>
<tr class="memdesc:aba911bf812fc9917b0848f3632a14b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the stream supports reading; otherwise, false.  <a href="#aba911bf812fc9917b0848f3632a14b83">More...</a><br /></td></tr>
<tr class="separator:aba911bf812fc9917b0848f3632a14b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c718966c21dfcc32c9e5bd1cd09aa"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#ad56c718966c21dfcc32c9e5bd1cd09aa">CanSeek</a><code> [get]</code></td></tr>
<tr class="memdesc:ad56c718966c21dfcc32c9e5bd1cd09aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the stream supports seeking; otherwise, false.  <a href="#ad56c718966c21dfcc32c9e5bd1cd09aa">More...</a><br /></td></tr>
<tr class="separator:ad56c718966c21dfcc32c9e5bd1cd09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c49d13919ba74627cb02da9fe7a06f"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a68c49d13919ba74627cb02da9fe7a06f">CanWrite</a><code> [get]</code></td></tr>
<tr class="memdesc:a68c49d13919ba74627cb02da9fe7a06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if stream supports writing; otherwise, false.  <a href="#a68c49d13919ba74627cb02da9fe7a06f">More...</a><br /></td></tr>
<tr class="separator:a68c49d13919ba74627cb02da9fe7a06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafd9a29ea57582d2cd3cabb278fe35"><td class="memItemLeft" align="right" valign="top">override long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#accafd9a29ea57582d2cd3cabb278fe35">Length</a><code> [get]</code></td></tr>
<tr class="memdesc:accafd9a29ea57582d2cd3cabb278fe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of stream in bytes  <a href="#accafd9a29ea57582d2cd3cabb278fe35">More...</a><br /></td></tr>
<tr class="separator:accafd9a29ea57582d2cd3cabb278fe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26768b9e2b18348bce38500be10bb534"><td class="memItemLeft" align="right" valign="top">override long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a26768b9e2b18348bce38500be10bb534">Position</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a26768b9e2b18348bce38500be10bb534"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets or sets the position within the current stream.  <a href="#a26768b9e2b18348bce38500be10bb534">More...</a><br /></td></tr>
<tr class="separator:a26768b9e2b18348bce38500be10bb534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a2b2ebc3683585a981e8224e06ec8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#af34a2b2ebc3683585a981e8224e06ec8">RecordSize</a><code> [get]</code></td></tr>
<tr class="memdesc:af34a2b2ebc3683585a981e8224e06ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the record size being used by this stream's <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>.  <a href="#af34a2b2ebc3683585a981e8224e06ec8">More...</a><br /></td></tr>
<tr class="separator:af34a2b2ebc3683585a981e8224e06ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write(). </p>
<p>public </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9c324e179a9735fd0c3c128bbc704c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c324e179a9735fd0c3c128bbc704c7c">&#9670;&nbsp;</a></span>TarOutputStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Tar.TarOutputStream.TarOutputStream </td>
          <td>(</td>
          <td class="paramtype">Stream&#160;</td>
          <td class="paramname"><em>outputStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> using default block factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputStream</td><td>stream to write to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb7670065482af0ce4f4be9c0d588a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7670065482af0ce4f4be9c0d588a15">&#9670;&nbsp;</a></span>TarOutputStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Tar.TarOutputStream.TarOutputStream </td>
          <td>(</td>
          <td class="paramtype">Stream&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html" title="The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries...">TarOutputStream</a> with user specified block factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputStream</td><td>stream to write to</td></tr>
    <tr><td class="paramname">blockFactor</td><td>blocking factor</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab744534cafac308f51f6586f06ca3d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab744534cafac308f51f6586f06ca3d86">&#9670;&nbsp;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void ICSharpCode.SharpZipLib.Tar.TarOutputStream.Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends the TAR archive and closes the underlying OutputStream. </p>
<p>This means that <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#a35766aed4ddf363bbaca72d33b0e071d" title="Ends the TAR archive without closing the underlying OutputStream. The result is that the EOF block of...">Finish()</a> is called followed by calling the <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>'s <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#ab744534cafac308f51f6586f06ca3d86" title="Ends the TAR archive and closes the underlying OutputStream. ">Close()</a>.</p>

</div>
</div>
<a id="a655ddc3a9e0219c85e900de5deb0cf74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ddc3a9e0219c85e900de5deb0cf74">&#9670;&nbsp;</a></span>CloseEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Tar.TarOutputStream.CloseEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close an entry. This method MUST be called for all file entries that contain data. The reason is that we must buffer data written to the stream in order to satisfy the buffer's block based writes. Thus, there may be data fragments still being assembled that must be written to the output stream before this entry is closed and the next entry written. </p>

</div>
</div>
<a id="a35766aed4ddf363bbaca72d33b0e071d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35766aed4ddf363bbaca72d33b0e071d">&#9670;&nbsp;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Tar.TarOutputStream.Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends the TAR archive without closing the underlying OutputStream. The result is that the EOF block of nulls is written. </p>

</div>
</div>
<a id="a477e87e93e590aecbf41527d8e1e8222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477e87e93e590aecbf41527d8e1e8222">&#9670;&nbsp;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void ICSharpCode.SharpZipLib.Tar.TarOutputStream.Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All buffered data is written to destination </p>

</div>
</div>
<a id="a3883f68913041868a45f1f257f490b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3883f68913041868a45f1f257f490b8f">&#9670;&nbsp;</a></span>GetRecordSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Tar.TarOutputStream.GetRecordSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the record size being used by this stream's <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a> record size. </dd></dl>

</div>
</div>
<a id="a0d0a70f8fb770a0be04b69944170c2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0a70f8fb770a0be04b69944170c2db">&#9670;&nbsp;</a></span>PutNextEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Tar.TarOutputStream.PutNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_entry.html">TarEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an entry on the output stream. This writes the entry's header and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry's contents. Once the contents are written, closeEntry() <b>MUST</b> be called to ensure that all buffered data is completely written to the output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_entry.html" title="This class represents an entry in a Tar archive. It consists of the entry&#39;s header, as well as the entry&#39;s File. Entries can be instantiated in one of three ways, depending on how they are to be used. ">TarEntry</a> to be written to the archive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81ff99bd6bbb5900972616c0df73b62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ff99bd6bbb5900972616c0df73b62d">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override int ICSharpCode.SharpZipLib.Tar.TarOutputStream.Read </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read bytes from the current stream and advance the position within the stream by the number of bytes read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store read bytes in.</td></tr>
    <tr><td class="paramname">offset</td><td>The index into the buffer to being storing bytes at.</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes read, or zero if at the end of the stream. The number of bytes may be less than the <em>count</em> count requested if data is not avialable.</dd></dl>

</div>
</div>
<a id="a3c252230a5bc39942e0417219dd732e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c252230a5bc39942e0417219dd732e6">&#9670;&nbsp;</a></span>ReadByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override int ICSharpCode.SharpZipLib.Tar.TarOutputStream.ReadByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a byte from the stream and advance the position within the stream by one byte or returns -1 if at the end of the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value or -1 if at end of stream</dd></dl>

</div>
</div>
<a id="a2c48071309528497f553f5b015503802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c48071309528497f553f5b015503802">&#9670;&nbsp;</a></span>Seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override long ICSharpCode.SharpZipLib.Tar.TarOutputStream.Seek </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SeekOrigin&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the position within the current stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the <em>origin</em>  to seek to</td></tr>
    <tr><td class="paramname">origin</td><td>The SeekOrigin to seek from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position in the stream.</dd></dl>

</div>
</div>
<a id="adc151653b44969093b2cfb6fd4cd6048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc151653b44969093b2cfb6fd4cd6048">&#9670;&nbsp;</a></span>SetLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void ICSharpCode.SharpZipLib.Tar.TarOutputStream.SetLength </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the length of the current stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new stream length.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0099fc6688112932356222e4aa16c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0099fc6688112932356222e4aa16c9">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void ICSharpCode.SharpZipLib.Tar.TarOutputStream.Write </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to write to the archive. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the buffer from which to get bytes. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a5cb90ae7900e926e78a299cf53893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a5cb90ae7900e926e78a299cf53893">&#9670;&nbsp;</a></span>WriteByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void ICSharpCode.SharpZipLib.Tar.TarOutputStream.WriteByte </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a byte to the current tar archive entry. This method simply calls Write(byte[], int, int). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The byte to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9a9684b64869d1db25f3b8ff15f160c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9684b64869d1db25f3b8ff15f160c6">&#9670;&nbsp;</a></span>assemblyBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte [] ICSharpCode.SharpZipLib.Tar.TarOutputStream.assemblyBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Assembly' buffer used to assemble data before writing </p>

</div>
</div>
<a id="aaa7fe07d3fe24316c6b3d85471897c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7fe07d3fe24316c6b3d85471897c66">&#9670;&nbsp;</a></span>blockBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte [] ICSharpCode.SharpZipLib.Tar.TarOutputStream.blockBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single block working buffer </p>

</div>
</div>
<a id="a5c3ade1fecb25c00a1e17af46cac1e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3ade1fecb25c00a1e17af46cac1e0b">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html">TarBuffer</a> ICSharpCode.SharpZipLib.Tar.TarOutputStream.buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a> used to provide correct blocking factor </p>

</div>
</div>
<a id="abe4e3aeed770f72702cfdf299afc56cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4e3aeed770f72702cfdf299afc56cf">&#9670;&nbsp;</a></span>currSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ICSharpCode.SharpZipLib.Tar.TarOutputStream.currSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size for the current entry </p>

</div>
</div>
<a id="a521e429618eb86a1a31242ec2d8e92b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521e429618eb86a1a31242ec2d8e92b0">&#9670;&nbsp;</a></span>outputStream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Stream ICSharpCode.SharpZipLib.Tar.TarOutputStream.outputStream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the destination stream for the archive contents </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="aba911bf812fc9917b0848f3632a14b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba911bf812fc9917b0848f3632a14b83">&#9670;&nbsp;</a></span>CanRead</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanRead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if the stream supports reading; otherwise, false. </p>

</div>
</div>
<a id="ad56c718966c21dfcc32c9e5bd1cd09aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56c718966c21dfcc32c9e5bd1cd09aa">&#9670;&nbsp;</a></span>CanSeek</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanSeek</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if the stream supports seeking; otherwise, false. </p>

</div>
</div>
<a id="a68c49d13919ba74627cb02da9fe7a06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c49d13919ba74627cb02da9fe7a06f">&#9670;&nbsp;</a></span>CanWrite</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool ICSharpCode.SharpZipLib.Tar.TarOutputStream.CanWrite</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if stream supports writing; otherwise, false. </p>

</div>
</div>
<a id="a5d30d12b3c98a5b45d17b54291e8b50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d30d12b3c98a5b45d17b54291e8b50d">&#9670;&nbsp;</a></span>IsStreamOwner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ICSharpCode.SharpZipLib.Tar.TarOutputStream.IsStreamOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get/set flag indicating ownership of the underlying stream. When the flag is true <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_output_stream.html#ab744534cafac308f51f6586f06ca3d86">Close</a> will close the underlying stream also. </p>

</div>
</div>
<a id="accafd9a29ea57582d2cd3cabb278fe35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accafd9a29ea57582d2cd3cabb278fe35">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override long ICSharpCode.SharpZipLib.Tar.TarOutputStream.Length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>length of stream in bytes </p>

</div>
</div>
<a id="a26768b9e2b18348bce38500be10bb534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26768b9e2b18348bce38500be10bb534">&#9670;&nbsp;</a></span>Position</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override long ICSharpCode.SharpZipLib.Tar.TarOutputStream.Position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets or sets the position within the current stream. </p>

</div>
</div>
<a id="af34a2b2ebc3683585a981e8224e06ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34a2b2ebc3683585a981e8224e06ec8">&#9670;&nbsp;</a></span>RecordSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Tar.TarOutputStream.RecordSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the record size being used by this stream's <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_tar_1_1_tar_buffer.html" title="The TarBuffer class implements the tar archive concept of a buffered input stream. This concept goes back to the days of blocked tape drives and special io devices. In the C# universe, the only real function that this class performs is to ensure that files have the correct &quot;record&quot; size, or other tars will complain. ">TarBuffer</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Project/Utility/SharpZIP/src/Tar/TarOutputStream.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
