<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_c_sharp_code.html">ICSharpCode</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib.html">SharpZipLib</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip.html">Zip</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression.html">Compression</a></li><li class="navelem"><a class="el" href="namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams.html">Streams</a></li><li class="navelem"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html">StreamManipulator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks.  
 <a href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a0bf52b7e926dbf3f3d7562ff1349106e">StreamManipulator</a> ()</td></tr>
<tr class="memdesc:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html" title="This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks. ">StreamManipulator</a> with all buffers empty  <a href="#a0bf52b7e926dbf3f3d7562ff1349106e">More...</a><br /></td></tr>
<tr class="separator:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffdc659e2508d7642be37f3c0fa1ec0"><td class="memItemLeft" align="right" valign="top">*&lt;/returns &gt; *int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0">PeekBits</a> (int bitCount)</td></tr>
<tr class="memdesc:acffdc659e2508d7642be37f3c0fa1ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sequence of bits but don't increase input pointer. bitCount must be less or equal 16 and if this call succeeds, you must drop at least n - 8 bits in the next call.  <a href="#acffdc659e2508d7642be37f3c0fa1ec0">More...</a><br /></td></tr>
<tr class="separator:acffdc659e2508d7642be37f3c0fa1ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a3593f65193421981087e5f32b6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3">DropBits</a> (int bitCount)</td></tr>
<tr class="memdesc:a133a3593f65193421981087e5f32b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before, to make sure that enough bits are in the bit buffer.  <a href="#a133a3593f65193421981087e5f32b6a3">More...</a><br /></td></tr>
<tr class="separator:a133a3593f65193421981087e5f32b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a2e01ba3e4c4dc842b4f230e04d45f415">GetBits</a> (int bitCount)</td></tr>
<tr class="memdesc:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next n bits and increases input pointer. This is equivalent to <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits</a> followed by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3" title="Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before...">DropBits</a>, except for correct error handling.  <a href="#a2e01ba3e4c4dc842b4f230e04d45f415">More...</a><br /></td></tr>
<tr class="separator:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e84082a23742801d9afa957e669d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a02e84082a23742801d9afa957e669d17">SkipToByteBoundary</a> ()</td></tr>
<tr class="memdesc:a02e84082a23742801d9afa957e669d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips to the next byte boundary.  <a href="#a02e84082a23742801d9afa957e669d17">More...</a><br /></td></tr>
<tr class="separator:a02e84082a23742801d9afa957e669d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdce04e996a38567367c80aa2c9b6f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#accdce04e996a38567367c80aa2c9b6f6">CopyBytes</a> (byte[] output, int offset, int length)</td></tr>
<tr class="memdesc:accdce04e996a38567367c80aa2c9b6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from input buffer to output buffer starting at output[offset]. You have to make sure, that the buffer is byte aligned. If not enough bytes are available, copies fewer bytes.  <a href="#accdce04e996a38567367c80aa2c9b6f6">More...</a><br /></td></tr>
<tr class="separator:accdce04e996a38567367c80aa2c9b6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf3e7c177c54bd0ad7fece9398de28b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#aabf3e7c177c54bd0ad7fece9398de28b">Reset</a> ()</td></tr>
<tr class="memdesc:aabf3e7c177c54bd0ad7fece9398de28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets state and empties internal buffers  <a href="#aabf3e7c177c54bd0ad7fece9398de28b">More...</a><br /></td></tr>
<tr class="separator:aabf3e7c177c54bd0ad7fece9398de28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c7062804a7b9b6be6008ba90e7038c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a48c7062804a7b9b6be6008ba90e7038c">SetInput</a> (byte[] buffer, int offset, int count)</td></tr>
<tr class="memdesc:a48c7062804a7b9b6be6008ba90e7038c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add more input for consumption. Only call when IsNeedingInput returns true  <a href="#a48c7062804a7b9b6be6008ba90e7038c">More...</a><br /></td></tr>
<tr class="separator:a48c7062804a7b9b6be6008ba90e7038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a0bf52b7e926dbf3f3d7562ff1349106e">StreamManipulator</a> ()</td></tr>
<tr class="memdesc:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html" title="This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks. ">StreamManipulator</a> with all buffers empty  <a href="#a0bf52b7e926dbf3f3d7562ff1349106e">More...</a><br /></td></tr>
<tr class="separator:a0bf52b7e926dbf3f3d7562ff1349106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffdc659e2508d7642be37f3c0fa1ec0"><td class="memItemLeft" align="right" valign="top">*&lt;/returns &gt; *int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0">PeekBits</a> (int bitCount)</td></tr>
<tr class="memdesc:acffdc659e2508d7642be37f3c0fa1ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sequence of bits but don't increase input pointer. bitCount must be less or equal 16 and if this call succeeds, you must drop at least n - 8 bits in the next call.  <a href="#acffdc659e2508d7642be37f3c0fa1ec0">More...</a><br /></td></tr>
<tr class="separator:acffdc659e2508d7642be37f3c0fa1ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a3593f65193421981087e5f32b6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3">DropBits</a> (int bitCount)</td></tr>
<tr class="memdesc:a133a3593f65193421981087e5f32b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before, to make sure that enough bits are in the bit buffer.  <a href="#a133a3593f65193421981087e5f32b6a3">More...</a><br /></td></tr>
<tr class="separator:a133a3593f65193421981087e5f32b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a2e01ba3e4c4dc842b4f230e04d45f415">GetBits</a> (int bitCount)</td></tr>
<tr class="memdesc:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next n bits and increases input pointer. This is equivalent to <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits</a> followed by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3" title="Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before...">DropBits</a>, except for correct error handling.  <a href="#a2e01ba3e4c4dc842b4f230e04d45f415">More...</a><br /></td></tr>
<tr class="separator:a2e01ba3e4c4dc842b4f230e04d45f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e84082a23742801d9afa957e669d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a02e84082a23742801d9afa957e669d17">SkipToByteBoundary</a> ()</td></tr>
<tr class="memdesc:a02e84082a23742801d9afa957e669d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips to the next byte boundary.  <a href="#a02e84082a23742801d9afa957e669d17">More...</a><br /></td></tr>
<tr class="separator:a02e84082a23742801d9afa957e669d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdce04e996a38567367c80aa2c9b6f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#accdce04e996a38567367c80aa2c9b6f6">CopyBytes</a> (byte[] output, int offset, int length)</td></tr>
<tr class="memdesc:accdce04e996a38567367c80aa2c9b6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from input buffer to output buffer starting at output[offset]. You have to make sure, that the buffer is byte aligned. If not enough bytes are available, copies fewer bytes.  <a href="#accdce04e996a38567367c80aa2c9b6f6">More...</a><br /></td></tr>
<tr class="separator:accdce04e996a38567367c80aa2c9b6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf3e7c177c54bd0ad7fece9398de28b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#aabf3e7c177c54bd0ad7fece9398de28b">Reset</a> ()</td></tr>
<tr class="memdesc:aabf3e7c177c54bd0ad7fece9398de28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets state and empties internal buffers  <a href="#aabf3e7c177c54bd0ad7fece9398de28b">More...</a><br /></td></tr>
<tr class="separator:aabf3e7c177c54bd0ad7fece9398de28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c7062804a7b9b6be6008ba90e7038c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a48c7062804a7b9b6be6008ba90e7038c">SetInput</a> (byte[] buffer, int offset, int count)</td></tr>
<tr class="memdesc:a48c7062804a7b9b6be6008ba90e7038c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add more input for consumption. Only call when IsNeedingInput returns true  <a href="#a48c7062804a7b9b6be6008ba90e7038c">More...</a><br /></td></tr>
<tr class="separator:a48c7062804a7b9b6be6008ba90e7038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a1ff254ed1ef5997b313db4b06204c6ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a1ff254ed1ef5997b313db4b06204c6ba">AvailableBits</a><code> [get]</code></td></tr>
<tr class="memdesc:a1ff254ed1ef5997b313db4b06204c6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bits available in the bit buffer. This must be only called when a previous <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits()</a> returned -1.  <a href="#a1ff254ed1ef5997b313db4b06204c6ba">More...</a><br /></td></tr>
<tr class="separator:a1ff254ed1ef5997b313db4b06204c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da2bc19cc20ef6c2de90e7b7bc32287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a7da2bc19cc20ef6c2de90e7b7bc32287">AvailableBytes</a><code> [get]</code></td></tr>
<tr class="memdesc:a7da2bc19cc20ef6c2de90e7b7bc32287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes available.  <a href="#a7da2bc19cc20ef6c2de90e7b7bc32287">More...</a><br /></td></tr>
<tr class="separator:a7da2bc19cc20ef6c2de90e7b7bc32287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc52ea538c6b83aeca7d0868ed52873"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#abdc52ea538c6b83aeca7d0868ed52873">IsNeedingInput</a><code> [get]</code></td></tr>
<tr class="memdesc:abdc52ea538c6b83aeca7d0868ed52873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when SetInput can be called  <a href="#abdc52ea538c6b83aeca7d0868ed52873">More...</a><br /></td></tr>
<tr class="separator:abdc52ea538c6b83aeca7d0868ed52873"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks. </p>
<p>It uses an int buffer to store up to 31 bits for direct manipulation. This guarantees that we can get at least 16 bits, but we only need at most 15, so this is all safe.</p>
<p>There are some optimizations in this class, for example, you must never peek more than 8 bits more than needed, and you must first peek bits before you may drop them. This is not a general purpose class but optimized for the behaviour of the <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_inflater.html" title="Inflater is used to decompress data that has been compressed according to the &quot;deflate&quot; standard desc...">Inflater</a>.</p>
<p>authors of the original java version : John Leuner, Jochen Hoenicke </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0bf52b7e926dbf3f3d7562ff1349106e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf52b7e926dbf3f3d7562ff1349106e">&#9670;&nbsp;</a></span>StreamManipulator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.StreamManipulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html" title="This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks. ">StreamManipulator</a> with all buffers empty </p>

</div>
</div>
<a id="a0bf52b7e926dbf3f3d7562ff1349106e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf52b7e926dbf3f3d7562ff1349106e">&#9670;&nbsp;</a></span>StreamManipulator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.StreamManipulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html" title="This class allows us to retrieve a specified number of bits from the input buffer, as well as copy big byte blocks. ">StreamManipulator</a> with all buffers empty </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accdce04e996a38567367c80aa2c9b6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdce04e996a38567367c80aa2c9b6f6">&#9670;&nbsp;</a></span>CopyBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bytes from input buffer to output buffer starting at output[offset]. You have to make sure, that the buffer is byte aligned. If not enough bytes are available, copies fewer bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The buffer to copy bytes to. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the buffer at which copying starts </td></tr>
    <tr><td class="paramname">length</td><td>The length to copy, 0 is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied, 0 if no bytes were available. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Length is less than zero </td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>Bit buffer isnt byte aligned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accdce04e996a38567367c80aa2c9b6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdce04e996a38567367c80aa2c9b6f6">&#9670;&nbsp;</a></span>CopyBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bytes from input buffer to output buffer starting at output[offset]. You have to make sure, that the buffer is byte aligned. If not enough bytes are available, copies fewer bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The buffer to copy bytes to. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the buffer at which copying starts </td></tr>
    <tr><td class="paramname">length</td><td>The length to copy, 0 is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied, 0 if no bytes were available. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>Length is less than zero </td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>Bit buffer isnt byte aligned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133a3593f65193421981087e5f32b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133a3593f65193421981087e5f32b6a3">&#9670;&nbsp;</a></span>DropBits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before, to make sure that enough bits are in the bit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to drop.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133a3593f65193421981087e5f32b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133a3593f65193421981087e5f32b6a3">&#9670;&nbsp;</a></span>DropBits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before, to make sure that enough bits are in the bit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to drop.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e01ba3e4c4dc842b4f230e04d45f415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e01ba3e4c4dc842b4f230e04d45f415">&#9670;&nbsp;</a></span>GetBits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next n bits and increases input pointer. This is equivalent to <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits</a> followed by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3" title="Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before...">DropBits</a>, except for correct error handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the bits, or -1 if not enough bits available. </dd></dl>

</div>
</div>
<a id="a2e01ba3e4c4dc842b4f230e04d45f415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e01ba3e4c4dc842b4f230e04d45f415">&#9670;&nbsp;</a></span>GetBits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next n bits and increases input pointer. This is equivalent to <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits</a> followed by <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#a133a3593f65193421981087e5f32b6a3" title="Drops the next n bits from the input. You should have called PeekBits with a bigger or equal n before...">DropBits</a>, except for correct error handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the bits, or -1 if not enough bits available. </dd></dl>

</div>
</div>
<a id="acffdc659e2508d7642be37f3c0fa1ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffdc659e2508d7642be37f3c0fa1ec0">&#9670;&nbsp;</a></span>PeekBits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">*&lt;/returns&gt; * int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next sequence of bits but don't increase input pointer. bitCount must be less or equal 16 and if this call succeeds, you must drop at least n - 8 bits in the next call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to peek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the bits, or -1 if not enough bits available. </dd></dl>

</div>
</div>
<a id="acffdc659e2508d7642be37f3c0fa1ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffdc659e2508d7642be37f3c0fa1ec0">&#9670;&nbsp;</a></span>PeekBits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">*&lt;/returns&gt; * int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next sequence of bits but don't increase input pointer. bitCount must be less or equal 16 and if this call succeeds, you must drop at least n - 8 bits in the next call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The number of bits to peek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the bits, or -1 if not enough bits available. </dd></dl>

</div>
</div>
<a id="aabf3e7c177c54bd0ad7fece9398de28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf3e7c177c54bd0ad7fece9398de28b">&#9670;&nbsp;</a></span>Reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets state and empties internal buffers </p>

</div>
</div>
<a id="aabf3e7c177c54bd0ad7fece9398de28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf3e7c177c54bd0ad7fece9398de28b">&#9670;&nbsp;</a></span>Reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets state and empties internal buffers </p>

</div>
</div>
<a id="a48c7062804a7b9b6be6008ba90e7038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c7062804a7b9b6be6008ba90e7038c">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add more input for consumption. Only call when IsNeedingInput returns true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to be input</td></tr>
    <tr><td class="paramname">offset</td><td>offset of first byte of input</td></tr>
    <tr><td class="paramname">count</td><td>number of bytes of input to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48c7062804a7b9b6be6008ba90e7038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c7062804a7b9b6be6008ba90e7038c">&#9670;&nbsp;</a></span>SetInput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput </td>
          <td>(</td>
          <td class="paramtype">byte []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add more input for consumption. Only call when IsNeedingInput returns true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to be input</td></tr>
    <tr><td class="paramname">offset</td><td>offset of first byte of input</td></tr>
    <tr><td class="paramname">count</td><td>number of bytes of input to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02e84082a23742801d9afa957e669d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e84082a23742801d9afa957e669d17">&#9670;&nbsp;</a></span>SkipToByteBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips to the next byte boundary. </p>

</div>
</div>
<a id="a02e84082a23742801d9afa957e669d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e84082a23742801d9afa957e669d17">&#9670;&nbsp;</a></span>SkipToByteBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips to the next byte boundary. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a1ff254ed1ef5997b313db4b06204c6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff254ed1ef5997b313db4b06204c6ba">&#9670;&nbsp;</a></span>AvailableBits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of bits available in the bit buffer. This must be only called when a previous <a class="el" href="class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_stream_manipulator.html#acffdc659e2508d7642be37f3c0fa1ec0" title="Get the next sequence of bits but don&#39;t increase input pointer. bitCount must be less or equal 16 and...">PeekBits()</a> returned -1. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bits available. </dd></dl>

</div>
</div>
<a id="a7da2bc19cc20ef6c2de90e7b7bc32287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da2bc19cc20ef6c2de90e7b7bc32287">&#9670;&nbsp;</a></span>AvailableBytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of bytes available. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available. </dd></dl>

</div>
</div>
<a id="abdc52ea538c6b83aeca7d0868ed52873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc52ea538c6b83aeca7d0868ed52873">&#9670;&nbsp;</a></span>IsNeedingInput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when SetInput can be called </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Project/Utility/SharpZIP/src/Zip/Compression/Streams/StreamManipulator.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
