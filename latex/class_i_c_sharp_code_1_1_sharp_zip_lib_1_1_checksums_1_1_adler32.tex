\hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{}\section{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32 Class Reference}
\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}\index{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32@{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32}}


Computes \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum for a stream of data. An \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum is not as reliable as a C\+R\+C32 checksum, but a lot faster to compute.  


Inheritance diagram for I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.848185cm]{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}{Adler32} ()
\begin{DoxyCompactList}\small\item\em Creates a new instance of the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} class. The checksum starts off with a value of 1. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}{Reset} ()
\begin{DoxyCompactList}\small\item\em Resets the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum to the initial value. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}{Update} (int value)
\begin{DoxyCompactList}\small\item\em Updates the checksum with a byte value. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}{Update} (byte\mbox{[}$\,$\mbox{]} buffer)
\begin{DoxyCompactList}\small\item\em Updates the checksum with an array of bytes. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}{Update} (byte\mbox{[}$\,$\mbox{]} buffer, int offset, int count)
\begin{DoxyCompactList}\small\item\em Updates the checksum with the bytes taken from the array. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}{Adler32} ()
\begin{DoxyCompactList}\small\item\em Creates a new instance of the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} class. The checksum starts off with a value of 1. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}{Reset} ()
\begin{DoxyCompactList}\small\item\em Resets the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum to the initial value. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}{Update} (int value)
\begin{DoxyCompactList}\small\item\em Updates the checksum with a byte value. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}{Update} (byte\mbox{[}$\,$\mbox{]} buffer)
\begin{DoxyCompactList}\small\item\em Updates the checksum with an array of bytes. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}{Update} (byte\mbox{[}$\,$\mbox{]} buffer, int offset, int count)
\begin{DoxyCompactList}\small\item\em Updates the checksum with the bytes taken from the array. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
long \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_aea4fd0d2f779009b33b4a780288db179}{Value}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} data checksum computed so far. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Computes \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum for a stream of data. An \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum is not as reliable as a C\+R\+C32 checksum, but a lot faster to compute. 

The specification for \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} may be found in R\+FC 1950. Z\+L\+IB Compressed Data Format Specification version 3.\+3)

From that document\+: \begin{DoxyVerb} "ADLER32 (Adler-32 checksum)
  This contains a checksum value of the uncompressed data
  (excluding any dictionary data) computed according to Adler-32
  algorithm. This algorithm is a 32-bit extension and improvement
  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
  standard.

  Adler-32 is composed of two sums accumulated per byte: s1 is
  the sum of all bytes, s2 is the sum of all s1 values. Both sums
  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
  Adler-32 checksum is stored as s2*65536 + s1 in most-
  significant-byte first (network) order."
\end{DoxyVerb}


"8.\+2. The Adler-\/32 algorithm

The Adler-\/32 algorithm is much faster than the C\+R\+C32 algorithm yet still provides an extremely low probability of undetected errors.

The modulo on unsigned long accumulators can be delayed for 5552 bytes, so the modulo operation time is negligible. If the bytes are a, b, c, the second sum is 3a + 2b + c + 3, and so is position and order sensitive, unlike the first sum, which is just a checksum. That 65521 is prime is important to avoid a possible large class of two-\/byte errors that leave the check unchanged. (The Fletcher checksum uses 255, which is not prime and which also makes the Fletcher check insensitive to single byte changes 0 -\/ 255.)

The sum s1 is initialized to 1 instead of zero to make the length of the sequence part of s2, so that the length does not have to be checked separately. (Any sequence of zeroes has a Fletcher checksum of zero.)" 

\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_inflater_input_stream}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Streams.\+Inflater\+Input\+Stream} \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_streams_1_1_deflater_output_stream}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Streams.\+Deflater\+Output\+Stream} 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Adler32@{Adler32}}
\index{Adler32@{Adler32}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Adler32()}{Adler32()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Adler32 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new instance of the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} class. The checksum starts off with a value of 1. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a972862f4f9c1bad593b4da0318299279}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Adler32@{Adler32}}
\index{Adler32@{Adler32}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Adler32()}{Adler32()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Adler32 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new instance of the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} class. The checksum starts off with a value of 1. 



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Reset@{Reset}}
\index{Reset@{Reset}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resets the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum to the initial value. 



Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_a43ef0e6e9e22a503da94790835a0a384}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ab508a341e82f164dfbb744188614caeb}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Reset@{Reset}}
\index{Reset@{Reset}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resets the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} checksum to the initial value. 



Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_a43ef0e6e9e22a503da94790835a0a384}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{int}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with a byte value. 


\begin{DoxyParams}{Parameters}
{\em value} & The data value to add. The high byte of the int is ignored. \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_a060abf360d877d0d9cf503fa6d6873d0}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ae37b99f42678909be303136f2995b572}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{int}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with a byte value. 


\begin{DoxyParams}{Parameters}
{\em value} & The data value to add. The high byte of the int is ignored. \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_a060abf360d877d0d9cf503fa6d6873d0}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with an array of bytes. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The source of the data to update with. \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_aee26d2b3705b22ab24cc9b5eb9dbc81d}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_a37a55dd34c64e5b9ea40ef50a6e23afd}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with an array of bytes. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The source of the data to update with. \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_aee26d2b3705b22ab24cc9b5eb9dbc81d}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{buffer,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with the bytes taken from the array. 


\begin{DoxyParams}{Parameters}
{\em buffer} & an array of bytes \\
\hline
{\em offset} & the start of the data used for this update \\
\hline
{\em count} & the number of bytes to use for this update \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_ae9f746b719a279125fd42e4d89f198dd}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_ad1fb412ee9a03ff079da149d0c06d0f6}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Update@{Update}}
\index{Update@{Update}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Update()}{Update()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Update (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{buffer,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the checksum with the bytes taken from the array. 


\begin{DoxyParams}{Parameters}
{\em buffer} & an array of bytes \\
\hline
{\em offset} & the start of the data used for this update \\
\hline
{\em count} & the number of bytes to use for this update \\
\hline
\end{DoxyParams}


Implements \hyperlink{interface_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_i_checksum_ae9f746b719a279125fd42e4d89f198dd}{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+I\+Checksum}.



\subsection{Property Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_aea4fd0d2f779009b33b4a780288db179}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32_aea4fd0d2f779009b33b4a780288db179}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}!Value@{Value}}
\index{Value@{Value}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Checksums\+::\+Adler32}}
\subsubsection{\texorpdfstring{Value}{Value}}
{\footnotesize\ttfamily long I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Checksums.\+Adler32.\+Value\hspace{0.3cm}{\ttfamily [get]}}



Returns the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_checksums_1_1_adler32}{Adler32} data checksum computed so far. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Project/\+Utility/\+Sharp\+Z\+I\+P/src/\+Checksums/Adler32.\+cs\end{DoxyCompactItemize}
