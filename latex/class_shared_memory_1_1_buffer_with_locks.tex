\hypertarget{class_shared_memory_1_1_buffer_with_locks}{}\section{Shared\+Memory.\+Buffer\+With\+Locks Class Reference}
\label{class_shared_memory_1_1_buffer_with_locks}\index{Shared\+Memory.\+Buffer\+With\+Locks@{Shared\+Memory.\+Buffer\+With\+Locks}}


 


Inheritance diagram for Shared\+Memory.\+Buffer\+With\+Locks\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.000000cm]{class_shared_memory_1_1_buffer_with_locks}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{class_shared_memory_1_1_buffer_with_locks_a836831324da16160986c52f8e063ff10}{Acquire\+Read\+Lock} (int milliseconds\+Timeout=System.\+Threading.\+Timeout.\+Infinite)
\begin{DoxyCompactList}\small\item\em Blocks the current thread until it is able to acquire a read lock. If successful all subsequent writes will be blocked until after a call to \hyperlink{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}{Release\+Read\+Lock}. \end{DoxyCompactList}\item 
void \hyperlink{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}{Release\+Read\+Lock} ()
\begin{DoxyCompactList}\small\item\em Releases the current read lock, allowing all blocked writes to continue. \end{DoxyCompactList}\item 
bool \hyperlink{class_shared_memory_1_1_buffer_with_locks_a309b191c69586043c60362e401732940}{Acquire\+Write\+Lock} (int milliseconds\+Timeout=System.\+Threading.\+Timeout.\+Infinite)
\begin{DoxyCompactList}\small\item\em Blocks the current thread until it is able to acquire a write lock. If successful all subsequent reads will be blocked until after a call to \hyperlink{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}{Release\+Write\+Lock}. \end{DoxyCompactList}\item 
void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}{Release\+Write\+Lock} ()
\begin{DoxyCompactList}\small\item\em Releases the current write lock, allowing all blocked reads to continue. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_shared_memory_1_1_buffer_with_locks_ac8f5ccb965d0a899744f5364c8140480}{Buffer\+With\+Locks} (string name, long buffer\+Size, bool owns\+Shared\+Memory)
\begin{DoxyCompactList}\small\item\em Create a new \hyperlink{class_shared_memory_1_1_buffer_with_locks}{Buffer\+With\+Locks} instance with the specified name and buffer size. \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a270a03b398be5cb2c9d3fca8be14129b}{Write$<$ T $>$} (ref T data, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Writes an instance of {\itshape T}  into the buffer \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a8abfbb585b8bdea85b9ff71111b55679}{Write$<$ T $>$} (T\mbox{[}$\,$\mbox{]} buffer, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Writes an array of {\itshape T}  into the buffer \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a13ed00d01404247565ad3caf1fc4a032}{Write} (Int\+Ptr ptr, int length, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Writes {\itshape length}  bytes from the {\itshape ptr}  into the shared memory buffer. \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a80c23992356dd3b7613f34223cf6b1fb}{Write} (Action$<$ Int\+Ptr $>$ write\+Func, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Prepares an Int\+Ptr to the buffer position and calls {\itshape write\+Func}  to perform the writing. \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a1c83bd463abef7c618efdcbe6e9fb317}{Read$<$ T $>$} (out T data, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Reads an instance of {\itshape T}  from the buffer \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a247e1e8f8f2849b65ee985f3b08cca97}{Read$<$ T $>$} (T\mbox{[}$\,$\mbox{]} buffer, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Reads an array of {\itshape T}  from the buffer \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_adf97b7891d30d2cc24ea39e232a0b238}{Read} (Int\+Ptr destination, int length, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Reads {\itshape length}  bytes into the memory location {\itshape destination}  from the shared memory buffer. \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a61d2f003963ccbedaff237c69814104d}{Read} (Action$<$ Int\+Ptr $>$ read\+Func, long buffer\+Position=0)
\begin{DoxyCompactList}\small\item\em Prepares an Int\+Ptr to the buffer position and calls {\itshape read\+Func}  to perform the reading. \end{DoxyCompactList}\item 
override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a3b01026691fcd0c1b2088ebabb0780d4}{Dispose} (bool dispose\+Managed\+Resources)
\begin{DoxyCompactList}\small\item\em I\+Disposable pattern \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
Event\+Wait\+Handle \hyperlink{class_shared_memory_1_1_buffer_with_locks_a5d7e21579a5af649e828e3a4e70f67e8}{Write\+Wait\+Event}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em An event handle used for blocking write operations. \end{DoxyCompactList}\item 
Event\+Wait\+Handle \hyperlink{class_shared_memory_1_1_buffer_with_locks_a93181710ceef6b88e2d7647f976f1e79}{Read\+Wait\+Event}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em An event handle used for blocking read operations. \end{DoxyCompactList}\item 
virtual int \hyperlink{class_shared_memory_1_1_buffer_with_locks_a5c1d09ad6c8629a8a8b7f2e5eca12e69}{Read\+Write\+Timeout}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The Read/\+Write operation timeout in milliseconds (to prevent deadlocks). Defaults to 100ms and must be larger than -\/1. If a Read or Write operation\textquotesingle{}s Wait\+Event does not complete within this timeframe a Timeout\+Exception will be thrown. If using Acquire\+Read\+Lock/\+Release\+Read\+Lock and Acquire\+Write\+Lock/\+Release\+Write\+Lock correctly this timeout will never occur. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Extends \hyperlink{class_shared_memory_1_1_shared_buffer}{Shared\+Buffer} to support simple thread-\/synchronisation for read/write to the buffer by allowing callers to acquire and release read/write locks.

All buffer read/write operations have been overloaded to first perform a System.\+Threading.\+Wait\+Handle.\+Wait\+One() using the \hyperlink{class_shared_memory_1_1_buffer_with_locks_a93181710ceef6b88e2d7647f976f1e79}{Read\+Wait\+Event} and \hyperlink{class_shared_memory_1_1_buffer_with_locks_a5d7e21579a5af649e828e3a4e70f67e8}{Write\+Wait\+Event} respectively.

By default all read/write operations will not block, it is necessary to first acquire locks through calls to \hyperlink{class_shared_memory_1_1_buffer_with_locks_a836831324da16160986c52f8e063ff10}{Acquire\+Read\+Lock} and \hyperlink{class_shared_memory_1_1_buffer_with_locks_a309b191c69586043c60362e401732940}{Acquire\+Write\+Lock} as appropriate, with corresponding calls to \hyperlink{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}{Release\+Read\+Lock} and \hyperlink{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}{Release\+Write\+Lock} to release the locks.

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_ac8f5ccb965d0a899744f5364c8140480}\label{class_shared_memory_1_1_buffer_with_locks_ac8f5ccb965d0a899744f5364c8140480}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Buffer\+With\+Locks@{Buffer\+With\+Locks}}
\index{Buffer\+With\+Locks@{Buffer\+With\+Locks}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Buffer\+With\+Locks()}{BufferWithLocks()}}
{\footnotesize\ttfamily Shared\+Memory.\+Buffer\+With\+Locks.\+Buffer\+With\+Locks (\begin{DoxyParamCaption}\item[{string}]{name,  }\item[{long}]{buffer\+Size,  }\item[{bool}]{owns\+Shared\+Memory }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Create a new \hyperlink{class_shared_memory_1_1_buffer_with_locks}{Buffer\+With\+Locks} instance with the specified name and buffer size. 


\begin{DoxyParams}{Parameters}
{\em name} & The name of the shared memory\\
\hline
{\em buffer\+Size} & The buffer size in bytes.\\
\hline
{\em owns\+Shared\+Memory} & Whether or not the current instance owns the shared memory. If true a new shared memory will be created and initialised otherwise an existing one is opened.\\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a836831324da16160986c52f8e063ff10}\label{class_shared_memory_1_1_buffer_with_locks_a836831324da16160986c52f8e063ff10}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Acquire\+Read\+Lock@{Acquire\+Read\+Lock}}
\index{Acquire\+Read\+Lock@{Acquire\+Read\+Lock}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Acquire\+Read\+Lock()}{AcquireReadLock()}}
{\footnotesize\ttfamily bool Shared\+Memory.\+Buffer\+With\+Locks.\+Acquire\+Read\+Lock (\begin{DoxyParamCaption}\item[{int}]{milliseconds\+Timeout = {\ttfamily System.Threading.Timeout.Infinite} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Blocks the current thread until it is able to acquire a read lock. If successful all subsequent writes will be blocked until after a call to \hyperlink{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}{Release\+Read\+Lock}. 


\begin{DoxyParams}{Parameters}
{\em milliseconds\+Timeout} & The number of milliseconds to wait, or System.\+Threading.\+Timeout.\+Infinite (-\/1) to wait indefinitely.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the read lock was able to be acquired, otherwise false.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & {\itshape milliseconds\+Timeout}  is a negative number other than -\/1, which represents an infinite time-\/out.\\
\hline
\end{DoxyExceptions}


If {\itshape milliseconds\+Timeout}  is System.\+Threading.\+Timeout.\+Infinite (-\/1), then attempting to acquire a read lock after acquiring a write lock on the same thread will result in a deadlock.\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a309b191c69586043c60362e401732940}\label{class_shared_memory_1_1_buffer_with_locks_a309b191c69586043c60362e401732940}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Acquire\+Write\+Lock@{Acquire\+Write\+Lock}}
\index{Acquire\+Write\+Lock@{Acquire\+Write\+Lock}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Acquire\+Write\+Lock()}{AcquireWriteLock()}}
{\footnotesize\ttfamily bool Shared\+Memory.\+Buffer\+With\+Locks.\+Acquire\+Write\+Lock (\begin{DoxyParamCaption}\item[{int}]{milliseconds\+Timeout = {\ttfamily System.Threading.Timeout.Infinite} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Blocks the current thread until it is able to acquire a write lock. If successful all subsequent reads will be blocked until after a call to \hyperlink{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}{Release\+Write\+Lock}. 


\begin{DoxyParams}{Parameters}
{\em milliseconds\+Timeout} & The number of milliseconds to wait, or System.\+Threading.\+Timeout.\+Infinite (-\/1) to wait indefinitely.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the write lock was able to be acquired, otherwise false.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & {\itshape milliseconds\+Timeout}  is a negative number other than -\/1, which represents an infinite time-\/out.\\
\hline
\end{DoxyExceptions}


If {\itshape milliseconds\+Timeout}  is System.\+Threading.\+Timeout.\+Infinite (-\/1), then attempting to acquire a write lock after acquiring a read lock on the same thread will result in a deadlock.\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a3b01026691fcd0c1b2088ebabb0780d4}\label{class_shared_memory_1_1_buffer_with_locks_a3b01026691fcd0c1b2088ebabb0780d4}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Dispose@{Dispose}}
\index{Dispose@{Dispose}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Dispose()}{Dispose()}}
{\footnotesize\ttfamily override void Shared\+Memory.\+Buffer\+With\+Locks.\+Dispose (\begin{DoxyParamCaption}\item[{bool}]{dispose\+Managed\+Resources }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



I\+Disposable pattern 


\begin{DoxyParams}{Parameters}
{\em dispose\+Managed\+Resources} & true to release managed resources\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_aa3db897346aa2c22a9d0d6b05ff7c058}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_adf97b7891d30d2cc24ea39e232a0b238}\label{class_shared_memory_1_1_buffer_with_locks_adf97b7891d30d2cc24ea39e232a0b238}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read@{Read}}
\index{Read@{Read}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily override void Shared\+Memory.\+Buffer\+With\+Locks.\+Read (\begin{DoxyParamCaption}\item[{Int\+Ptr}]{destination,  }\item[{int}]{length,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Reads {\itshape length}  bytes into the memory location {\itshape destination}  from the shared memory buffer. 


\begin{DoxyParams}{Parameters}
{\em destination} & A managed pointer to the memory location to copy data into from the buffer\\
\hline
{\em length} & The number of bytes to be copied\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to read from.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_a95407dfdc38af1afeeb9a9c4a8569982}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a61d2f003963ccbedaff237c69814104d}\label{class_shared_memory_1_1_buffer_with_locks_a61d2f003963ccbedaff237c69814104d}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read@{Read}}
\index{Read@{Read}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily override void Shared\+Memory.\+Buffer\+With\+Locks.\+Read (\begin{DoxyParamCaption}\item[{Action$<$ Int\+Ptr $>$}]{read\+Func,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Prepares an Int\+Ptr to the buffer position and calls {\itshape read\+Func}  to perform the reading. 


\begin{DoxyParams}{Parameters}
{\em read\+Func} & A function used to read from the buffer. The Int\+Ptr parameter is a pointer to the buffer offset by {\itshape buffer\+Position} .\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to read from.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_aea88361c8c00b0159fe3dacc769a8465}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a1c83bd463abef7c618efdcbe6e9fb317}\label{class_shared_memory_1_1_buffer_with_locks_a1c83bd463abef7c618efdcbe6e9fb317}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read$<$ T $>$@{Read$<$ T $>$}}
\index{Read$<$ T $>$@{Read$<$ T $>$}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read$<$ T $>$()}{Read< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_adf97b7891d30d2cc24ea39e232a0b238}{Shared\+Memory.\+Buffer\+With\+Locks.\+Read}$<$ T $>$ (\begin{DoxyParamCaption}\item[{out T}]{data,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Reads an instance of {\itshape T}  from the buffer 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & A structure type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Output parameter that will contain the value read from the buffer\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to read from.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_a27d48f6be3b300882aa9aa71339421be}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a247e1e8f8f2849b65ee985f3b08cca97}\label{class_shared_memory_1_1_buffer_with_locks_a247e1e8f8f2849b65ee985f3b08cca97}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read$<$ T $>$@{Read$<$ T $>$}}
\index{Read$<$ T $>$@{Read$<$ T $>$}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read$<$ T $>$()}{Read< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_adf97b7891d30d2cc24ea39e232a0b238}{Shared\+Memory.\+Buffer\+With\+Locks.\+Read}$<$ T $>$ (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{buffer,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Reads an array of {\itshape T}  from the buffer 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & A structure type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em buffer} & Array that will contain the values read from the buffer. The length of this array controls the number of elements to read.\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to read from.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_aba5489c699f444012792fd6331affb03}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}\label{class_shared_memory_1_1_buffer_with_locks_adb9c96d006822a210e98f71c22c05bf5}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Release\+Read\+Lock@{Release\+Read\+Lock}}
\index{Release\+Read\+Lock@{Release\+Read\+Lock}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Release\+Read\+Lock()}{ReleaseReadLock()}}
{\footnotesize\ttfamily void Shared\+Memory.\+Buffer\+With\+Locks.\+Release\+Read\+Lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Releases the current read lock, allowing all blocked writes to continue. 

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}\label{class_shared_memory_1_1_buffer_with_locks_a9032d217f1f869d62ea29b3a3ea3fb98}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Release\+Write\+Lock@{Release\+Write\+Lock}}
\index{Release\+Write\+Lock@{Release\+Write\+Lock}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Release\+Write\+Lock()}{ReleaseWriteLock()}}
{\footnotesize\ttfamily void Shared\+Memory.\+Buffer\+With\+Locks.\+Release\+Write\+Lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Releases the current write lock, allowing all blocked reads to continue. 

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a13ed00d01404247565ad3caf1fc4a032}\label{class_shared_memory_1_1_buffer_with_locks_a13ed00d01404247565ad3caf1fc4a032}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Write@{Write}}
\index{Write@{Write}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Write()}{Write()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily override void Shared\+Memory.\+Buffer\+With\+Locks.\+Write (\begin{DoxyParamCaption}\item[{Int\+Ptr}]{ptr,  }\item[{int}]{length,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Writes {\itshape length}  bytes from the {\itshape ptr}  into the shared memory buffer. 


\begin{DoxyParams}{Parameters}
{\em ptr} & A managed pointer to the memory location to be copied into the buffer\\
\hline
{\em length} & The number of bytes to be copied\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to write to.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_acbe85aa71eaf1624fa5e03c0b026fa52}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a80c23992356dd3b7613f34223cf6b1fb}\label{class_shared_memory_1_1_buffer_with_locks_a80c23992356dd3b7613f34223cf6b1fb}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Write@{Write}}
\index{Write@{Write}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Write()}{Write()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily override void Shared\+Memory.\+Buffer\+With\+Locks.\+Write (\begin{DoxyParamCaption}\item[{Action$<$ Int\+Ptr $>$}]{write\+Func,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Prepares an Int\+Ptr to the buffer position and calls {\itshape write\+Func}  to perform the writing. 


\begin{DoxyParams}{Parameters}
{\em write\+Func} & A function used to write to the buffer. The Int\+Ptr parameter is a pointer to the buffer offset by {\itshape buffer\+Position} .\\
\hline
{\em buffer\+Position} & The offset within the buffer region to start writing from.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_abc575d2ef1f8df8cc05fadb1b96b22e8}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a270a03b398be5cb2c9d3fca8be14129b}\label{class_shared_memory_1_1_buffer_with_locks_a270a03b398be5cb2c9d3fca8be14129b}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Write$<$ T $>$@{Write$<$ T $>$}}
\index{Write$<$ T $>$@{Write$<$ T $>$}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Write$<$ T $>$()}{Write< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a13ed00d01404247565ad3caf1fc4a032}{Shared\+Memory.\+Buffer\+With\+Locks.\+Write}$<$ T $>$ (\begin{DoxyParamCaption}\item[{ref T}]{data,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Writes an instance of {\itshape T}  into the buffer 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & A structure type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & A reference to an instance of {\itshape T}  to be written\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to write to.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_a82edbe6f30b012bc93f098db46a582ec}{Shared\+Memory.\+Shared\+Buffer}.

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a8abfbb585b8bdea85b9ff71111b55679}\label{class_shared_memory_1_1_buffer_with_locks_a8abfbb585b8bdea85b9ff71111b55679}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Write$<$ T $>$@{Write$<$ T $>$}}
\index{Write$<$ T $>$@{Write$<$ T $>$}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Write$<$ T $>$()}{Write< T >()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily override void \hyperlink{class_shared_memory_1_1_buffer_with_locks_a13ed00d01404247565ad3caf1fc4a032}{Shared\+Memory.\+Buffer\+With\+Locks.\+Write}$<$ T $>$ (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{buffer,  }\item[{long}]{buffer\+Position = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Writes an array of {\itshape T}  into the buffer 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & A structure type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em buffer} & An array of {\itshape T}  to be written. The length of this array controls the number of elements to be written.\\
\hline
{\em buffer\+Position} & The offset within the buffer region of the shared memory to write to.\\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{class_shared_memory_1_1_shared_buffer_aff9ac6982aca4308738395c9a583d50e}{Shared\+Memory.\+Shared\+Buffer}.



\subsection{Property Documentation}
\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a93181710ceef6b88e2d7647f976f1e79}\label{class_shared_memory_1_1_buffer_with_locks_a93181710ceef6b88e2d7647f976f1e79}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read\+Wait\+Event@{Read\+Wait\+Event}}
\index{Read\+Wait\+Event@{Read\+Wait\+Event}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read\+Wait\+Event}{ReadWaitEvent}}
{\footnotesize\ttfamily Event\+Wait\+Handle Shared\+Memory.\+Buffer\+With\+Locks.\+Read\+Wait\+Event\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected]}}



An event handle used for blocking read operations. 

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a5c1d09ad6c8629a8a8b7f2e5eca12e69}\label{class_shared_memory_1_1_buffer_with_locks_a5c1d09ad6c8629a8a8b7f2e5eca12e69}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Read\+Write\+Timeout@{Read\+Write\+Timeout}}
\index{Read\+Write\+Timeout@{Read\+Write\+Timeout}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Read\+Write\+Timeout}{ReadWriteTimeout}}
{\footnotesize\ttfamily virtual int Shared\+Memory.\+Buffer\+With\+Locks.\+Read\+Write\+Timeout\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The Read/\+Write operation timeout in milliseconds (to prevent deadlocks). Defaults to 100ms and must be larger than -\/1. If a Read or Write operation\textquotesingle{}s Wait\+Event does not complete within this timeframe a Timeout\+Exception will be thrown. If using Acquire\+Read\+Lock/\+Release\+Read\+Lock and Acquire\+Write\+Lock/\+Release\+Write\+Lock correctly this timeout will never occur. 

\mbox{\Hypertarget{class_shared_memory_1_1_buffer_with_locks_a5d7e21579a5af649e828e3a4e70f67e8}\label{class_shared_memory_1_1_buffer_with_locks_a5d7e21579a5af649e828e3a4e70f67e8}} 
\index{Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}!Write\+Wait\+Event@{Write\+Wait\+Event}}
\index{Write\+Wait\+Event@{Write\+Wait\+Event}!Shared\+Memory\+::\+Buffer\+With\+Locks@{Shared\+Memory\+::\+Buffer\+With\+Locks}}
\subsubsection{\texorpdfstring{Write\+Wait\+Event}{WriteWaitEvent}}
{\footnotesize\ttfamily Event\+Wait\+Handle Shared\+Memory.\+Buffer\+With\+Locks.\+Write\+Wait\+Event\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected]}}



An event handle used for blocking write operations. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Project/\+Backports/\+Shared\+Memory/Buffer\+With\+Locks.\+cs\end{DoxyCompactItemize}
