\hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater}{}\section{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater Class Reference}
\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater}\index{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater@{I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater}}


This is the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater}{Deflater} class. The deflater class compresses input with the deflate algorithm described in R\+FC 1951. It has several compression levels and three different strategies described below.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}{Deflater} ()
\begin{DoxyCompactList}\small\item\em Creates a new deflater with default compression level. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}{Deflater} (int level)
\begin{DoxyCompactList}\small\item\em Creates a new deflater with given compression level. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}{Deflater} (int level, bool no\+Zlib\+Header\+Or\+Footer)
\begin{DoxyCompactList}\small\item\em Creates a new deflater with given compression level. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}{Reset} ()
\begin{DoxyCompactList}\small\item\em Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}{Flush} ()
\begin{DoxyCompactList}\small\item\em Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun\textquotesingle{}s J\+DK so I have made it package private. It is used by Deflater\+Output\+Stream to implement flush(). \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish} ()
\begin{DoxyCompactList}\small\item\em Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}{Set\+Input} (byte\mbox{[}$\,$\mbox{]} input)
\begin{DoxyCompactList}\small\item\em Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. If you call set\+Input when needs\+Input() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needs\+Input() returns true again. This call is equivalent to \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}{Set\+Input} (byte\mbox{[}$\,$\mbox{]} input, int offset, int count)
\begin{DoxyCompactList}\small\item\em Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. The given byte array should not be changed, before needs\+Input() returns true again. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level} (int level)
\begin{DoxyCompactList}\small\item\em Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needs\+Input is true the change of compression level will occur somewhere near before the end of the so far given input. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}{Get\+Level} ()
\begin{DoxyCompactList}\small\item\em Get current compression level \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}{Set\+Strategy} (\hyperlink{namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_a922c175879503e6b9e35641deccfbc40}{Deflate\+Strategy} strategy)
\begin{DoxyCompactList}\small\item\em Sets the compression strategy. Strategy is one of D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+T\+R\+A\+T\+E\+GY, H\+U\+F\+F\+M\+A\+N\+\_\+\+O\+N\+LY and F\+I\+L\+T\+E\+R\+ED. For the exact position where the strategy is changed, the same as for \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level()} applies. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}{Deflate} (byte\mbox{[}$\,$\mbox{]} output)
\begin{DoxyCompactList}\small\item\em Deflates the current input block with to the given array. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}{Deflate} (byte\mbox{[}$\,$\mbox{]} output, int offset, int length)
\begin{DoxyCompactList}\small\item\em Deflates the current input block to the given array. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}{Set\+Dictionary} (byte\mbox{[}$\,$\mbox{]} dictionary)
\begin{DoxyCompactList}\small\item\em Sets the dictionary which should be used in the deflate process. This call is equivalent to \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}{Set\+Dictionary} (byte\mbox{[}$\,$\mbox{]} dictionary, int index, int count)
\begin{DoxyCompactList}\small\item\em Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}{Deflater} ()
\begin{DoxyCompactList}\small\item\em Creates a new deflater with default compression level. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}{Deflater} (int level)
\begin{DoxyCompactList}\small\item\em Creates a new deflater with given compression level. \end{DoxyCompactList}\item 
\hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}{Deflater} (int level, bool no\+Zlib\+Header\+Or\+Footer)
\begin{DoxyCompactList}\small\item\em Creates a new deflater with given compression level. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}{Reset} ()
\begin{DoxyCompactList}\small\item\em Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}{Flush} ()
\begin{DoxyCompactList}\small\item\em Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun\textquotesingle{}s J\+DK so I have made it package private. It is used by Deflater\+Output\+Stream to implement flush(). \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish} ()
\begin{DoxyCompactList}\small\item\em Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}{Set\+Input} (byte\mbox{[}$\,$\mbox{]} input)
\begin{DoxyCompactList}\small\item\em Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. If you call set\+Input when needs\+Input() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needs\+Input() returns true again. This call is equivalent to \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}{Set\+Input} (byte\mbox{[}$\,$\mbox{]} input, int offset, int count)
\begin{DoxyCompactList}\small\item\em Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. The given byte array should not be changed, before needs\+Input() returns true again. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level} (int level)
\begin{DoxyCompactList}\small\item\em Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needs\+Input is true the change of compression level will occur somewhere near before the end of the so far given input. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}{Get\+Level} ()
\begin{DoxyCompactList}\small\item\em Get current compression level \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}{Set\+Strategy} (\hyperlink{namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_a922c175879503e6b9e35641deccfbc40}{Deflate\+Strategy} strategy)
\begin{DoxyCompactList}\small\item\em Sets the compression strategy. Strategy is one of D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+T\+R\+A\+T\+E\+GY, H\+U\+F\+F\+M\+A\+N\+\_\+\+O\+N\+LY and F\+I\+L\+T\+E\+R\+ED. For the exact position where the strategy is changed, the same as for \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level()} applies. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}{Deflate} (byte\mbox{[}$\,$\mbox{]} output)
\begin{DoxyCompactList}\small\item\em Deflates the current input block with to the given array. \end{DoxyCompactList}\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}{Deflate} (byte\mbox{[}$\,$\mbox{]} output, int offset, int length)
\begin{DoxyCompactList}\small\item\em Deflates the current input block to the given array. \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}{Set\+Dictionary} (byte\mbox{[}$\,$\mbox{]} dictionary)
\begin{DoxyCompactList}\small\item\em Sets the dictionary which should be used in the deflate process. This call is equivalent to \end{DoxyCompactList}\item 
void \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}{Set\+Dictionary} (byte\mbox{[}$\,$\mbox{]} dictionary, int index, int count)
\begin{DoxyCompactList}\small\item\em Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a48bb9f670d4d5783fe8d961c94abc6c5}{B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON} = 9
\begin{DoxyCompactList}\small\item\em The best and slowest compression level. This tries to find very long and distant string repetitions. \end{DoxyCompactList}\item 
const int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a2cdcb79df38a40a31551bf83e136c341}{B\+E\+S\+T\+\_\+\+S\+P\+E\+ED} = 1
\begin{DoxyCompactList}\small\item\em The worst but fastest compression level. \end{DoxyCompactList}\item 
const int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a46b1664d22d2ba8d08620b3ff848063b}{D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON} = -\/1
\begin{DoxyCompactList}\small\item\em The default compression level. \end{DoxyCompactList}\item 
const int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a7bbbdacd59167e196eef92c3753b37ff}{N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON} = 0
\begin{DoxyCompactList}\small\item\em This level won\textquotesingle{}t compress at all but output uncompressed blocks. \end{DoxyCompactList}\item 
const int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a3d3465bd16292776ddcf2f5a6fa4c134}{D\+E\+F\+L\+A\+T\+ED} = 8
\begin{DoxyCompactList}\small\item\em The compression method. This is the only method supported so far. There is no need to use this constant at all. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a074fbfc52ac8f635b64b2c58cd2b3f95}{Adler}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the current adler checksum of the data that was processed so far. \end{DoxyCompactList}\item 
long \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4693c429dd0f79c65497f95649da225e}{Total\+In}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the number of input bytes processed so far. \end{DoxyCompactList}\item 
long \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a5cd8c55b5c101ba971532affb54f88af}{Total\+Out}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the number of output bytes so far. \end{DoxyCompactList}\item 
bool \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aabbabbf940655a8832a8ed57d8804fa7}{Is\+Finished}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns true if the stream was finished and no more output bytes are available. \end{DoxyCompactList}\item 
bool \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aab8aa7baaad840eb260ff1e0385fe116}{Is\+Needing\+Input}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns true, if the input buffer is empty. You should then call set\+Input(). N\+O\+TE\+: This method can also return true when the stream was finished. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is the \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater}{Deflater} class. The deflater class compresses input with the deflate algorithm described in R\+FC 1951. It has several compression levels and three different strategies described below. 

This class is {\itshape not} thread safe. This is inherent in the A\+PI, due to the split of deflate and set\+Input.

author of the original java version \+: Jochen Hoenicke 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with default compression level. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}\item[{int}]{level }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with given compression level. 


\begin{DoxyParams}{Parameters}
{\em level} & the compression level, a value between N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON and B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON, or D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & if lvl is out of range.\\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}\item[{int}]{level,  }\item[{bool}]{no\+Zlib\+Header\+Or\+Footer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with given compression level. 


\begin{DoxyParams}{Parameters}
{\em level} & the compression level, a value between N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON and B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON. \\
\hline
{\em no\+Zlib\+Header\+Or\+Footer} & true, if we should suppress the Zlib/\+R\+F\+C1950 header at the beginning and the adler checksum at the end of the output. This is useful for the G\+Z\+I\+P/\+P\+K\+Z\+IP formats. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & if lvl is out of range.\\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aef92661d02455221261ea607e29710f2}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with default compression level. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a038451ce25b9917398218c5c741e9fb2}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}\item[{int}]{level }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with given compression level. 


\begin{DoxyParams}{Parameters}
{\em level} & the compression level, a value between N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON and B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON, or D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & if lvl is out of range.\\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a8bfca90e822ab3e9984ad3287e95a61a}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflater@{Deflater}}
\index{Deflater@{Deflater}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflater()}{Deflater()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflater (\begin{DoxyParamCaption}\item[{int}]{level,  }\item[{bool}]{no\+Zlib\+Header\+Or\+Footer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new deflater with given compression level. 


\begin{DoxyParams}{Parameters}
{\em level} & the compression level, a value between N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON and B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON. \\
\hline
{\em no\+Zlib\+Header\+Or\+Footer} & true, if we should suppress the Zlib/\+R\+F\+C1950 header at the beginning and the adler checksum at the end of the output. This is useful for the G\+Z\+I\+P/\+P\+K\+Z\+IP formats. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & if lvl is out of range.\\
\hline
\end{DoxyExceptions}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflate@{Deflate}}
\index{Deflate@{Deflate}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflate()}{Deflate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflate (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{output }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deflates the current input block with to the given array. 


\begin{DoxyParams}{Parameters}
{\em output} & The buffer where compressed data is stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of compressed bytes added to the output, or 0 if either \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aab8aa7baaad840eb260ff1e0385fe116}{Is\+Needing\+Input()} or Is\+Finished returns true or length is zero. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflate@{Deflate}}
\index{Deflate@{Deflate}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflate()}{Deflate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflate (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{output,  }\item[{int}]{offset,  }\item[{int}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deflates the current input block to the given array. 


\begin{DoxyParams}{Parameters}
{\em output} & Buffer to store the compressed data. \\
\hline
{\em offset} & Offset into the output array. \\
\hline
{\em length} & The maximum number of bytes that may be stored. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of compressed bytes added to the output, or 0 if either needs\+Input() or finished() returns true or length is zero. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & If \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish()} was previously called. \\
\hline
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & If offset or length don\textquotesingle{}t match the array length. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflate@{Deflate}}
\index{Deflate@{Deflate}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflate()}{Deflate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflate (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{output }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deflates the current input block with to the given array. 


\begin{DoxyParams}{Parameters}
{\em output} & The buffer where compressed data is stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of compressed bytes added to the output, or 0 if either \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aab8aa7baaad840eb260ff1e0385fe116}{Is\+Needing\+Input()} or Is\+Finished returns true or length is zero. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1611ccb20064abb42667e5cbf7b98c4a}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Deflate@{Deflate}}
\index{Deflate@{Deflate}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Deflate()}{Deflate()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Deflate (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{output,  }\item[{int}]{offset,  }\item[{int}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deflates the current input block to the given array. 


\begin{DoxyParams}{Parameters}
{\em output} & Buffer to store the compressed data. \\
\hline
{\em offset} & Offset into the output array. \\
\hline
{\em length} & The maximum number of bytes that may be stored. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of compressed bytes added to the output, or 0 if either needs\+Input() or finished() returns true or length is zero. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & If \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish()} was previously called. \\
\hline
{\em System.\+Argument\+Out\+Of\+Range\+Exception} & If offset or length don\textquotesingle{}t match the array length. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Finish@{Finish}}
\index{Finish@{Finish}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Finish()}{Finish()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Finish (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Finish@{Finish}}
\index{Finish@{Finish}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Finish()}{Finish()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Finish (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finishes the deflater with the current input block. It is an error to give more input after this method was called. This method must be called to force all bytes to be flushed. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Flush@{Flush}}
\index{Flush@{Flush}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Flush()}{Flush()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Flush (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun\textquotesingle{}s J\+DK so I have made it package private. It is used by Deflater\+Output\+Stream to implement flush(). 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a98a7b88b7209a07bcd5f69ab94863116}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Flush@{Flush}}
\index{Flush@{Flush}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Flush()}{Flush()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Flush (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Flushes the current input block. Further calls to deflate() will produce enough output to inflate everything in the current input block. This is not part of Sun\textquotesingle{}s J\+DK so I have made it package private. It is used by Deflater\+Output\+Stream to implement flush(). 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Get\+Level@{Get\+Level}}
\index{Get\+Level@{Get\+Level}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Get\+Level()}{GetLevel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Get\+Level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get current compression level 

\begin{DoxyReturn}{Returns}
Returns the current compression level
\end{DoxyReturn}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_af90d5712ba8aa8a034ee63125d747c71}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Get\+Level@{Get\+Level}}
\index{Get\+Level@{Get\+Level}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Get\+Level()}{GetLevel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Get\+Level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get current compression level 

\begin{DoxyReturn}{Returns}
Returns the current compression level
\end{DoxyReturn}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Reset@{Reset}}
\index{Reset@{Reset}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a61fe4fb8d97829e1910afbe6fd8be79c}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Reset@{Reset}}
\index{Reset@{Reset}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resets the deflater. The deflater acts afterwards as if it was just created with the same compression level and strategy as it had before. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Dictionary@{Set\+Dictionary}}
\index{Set\+Dictionary@{Set\+Dictionary}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Dictionary()}{SetDictionary()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Dictionary (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{dictionary }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the dictionary which should be used in the deflate process. This call is equivalent to 

{\ttfamily set\+Dictionary(dict, 0, dict.\+Length)}. 


\begin{DoxyParams}{Parameters}
{\em dictionary} & the dictionary. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if Set\+Input () or Deflate () were already called or another dictionary was already set. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Dictionary@{Set\+Dictionary}}
\index{Set\+Dictionary@{Set\+Dictionary}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Dictionary()}{SetDictionary()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Dictionary (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{dictionary,  }\item[{int}]{index,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. 


\begin{DoxyParams}{Parameters}
{\em dictionary} & The dictionary data \\
\hline
{\em index} & The index where dictionary information commences. \\
\hline
{\em count} & The number of bytes in the dictionary. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & If Set\+Input () or \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}{Deflate()} were already called or another dictionary was already set. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a37d15527b9581210462405f0d6fc05f9}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Dictionary@{Set\+Dictionary}}
\index{Set\+Dictionary@{Set\+Dictionary}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Dictionary()}{SetDictionary()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Dictionary (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{dictionary }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the dictionary which should be used in the deflate process. This call is equivalent to 

{\ttfamily set\+Dictionary(dict, 0, dict.\+Length)}. 


\begin{DoxyParams}{Parameters}
{\em dictionary} & the dictionary. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if Set\+Input () or Deflate () were already called or another dictionary was already set. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a32ef3ee267c15d7a292d6e992c435160}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Dictionary@{Set\+Dictionary}}
\index{Set\+Dictionary@{Set\+Dictionary}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Dictionary()}{SetDictionary()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Dictionary (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{dictionary,  }\item[{int}]{index,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the dictionary which should be used in the deflate process. The dictionary is a byte array containing strings that are likely to occur in the data which should be compressed. The dictionary is not stored in the compressed output, only a checksum. To decompress the output you need to supply the same dictionary again. 


\begin{DoxyParams}{Parameters}
{\em dictionary} & The dictionary data \\
\hline
{\em index} & The index where dictionary information commences. \\
\hline
{\em count} & The number of bytes in the dictionary. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & If Set\+Input () or \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a68958680d1f6cdaef83e705908e5c082}{Deflate()} were already called or another dictionary was already set. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Input@{Set\+Input}}
\index{Set\+Input@{Set\+Input}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Input()}{SetInput()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Input (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{input }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. If you call set\+Input when needs\+Input() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needs\+Input() returns true again. This call is equivalent to 

{\ttfamily set\+Input(input, 0, input.\+length)}. 


\begin{DoxyParams}{Parameters}
{\em input} & the buffer containing the input data. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if the buffer was finished() or ended(). \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a47dd1a3f861adb774c5a31414ad55667}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Input@{Set\+Input}}
\index{Set\+Input@{Set\+Input}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Input()}{SetInput()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Input (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{input }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. If you call set\+Input when needs\+Input() returns false, the previous input that is still pending will be thrown away. The given byte array should not be changed, before needs\+Input() returns true again. This call is equivalent to 

{\ttfamily set\+Input(input, 0, input.\+length)}. 


\begin{DoxyParams}{Parameters}
{\em input} & the buffer containing the input data. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if the buffer was finished() or ended(). \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Input@{Set\+Input}}
\index{Set\+Input@{Set\+Input}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Input()}{SetInput()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Input (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{input,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. The given byte array should not be changed, before needs\+Input() returns true again. 


\begin{DoxyParams}{Parameters}
{\em input} & the buffer containing the input data. \\
\hline
{\em offset} & the start of the data. \\
\hline
{\em count} & the number of data bytes of input. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if the buffer was \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish()}ed or if previous input is still pending. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1b655a78dff6b6fa7374740f63342f25}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Input@{Set\+Input}}
\index{Set\+Input@{Set\+Input}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Input()}{SetInput()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Input (\begin{DoxyParamCaption}\item[{byte \mbox{[}$\,$\mbox{]}}]{input,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the data which should be compressed next. This should be only called when needs\+Input indicates that more input is needed. The given byte array should not be changed, before needs\+Input() returns true again. 


\begin{DoxyParams}{Parameters}
{\em input} & the buffer containing the input data. \\
\hline
{\em offset} & the start of the data. \\
\hline
{\em count} & the number of data bytes of input. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & if the buffer was \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4a1b79d68b91057d4044d1d657b81f6c}{Finish()}ed or if previous input is still pending. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Level@{Set\+Level}}
\index{Set\+Level@{Set\+Level}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Level()}{SetLevel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Level (\begin{DoxyParamCaption}\item[{int}]{level }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needs\+Input is true the change of compression level will occur somewhere near before the end of the so far given input. 


\begin{DoxyParams}{Parameters}
{\em level} & the new compression level. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Level@{Set\+Level}}
\index{Set\+Level@{Set\+Level}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Level()}{SetLevel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Level (\begin{DoxyParamCaption}\item[{int}]{level }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the compression level. There is no guarantee of the exact position of the change, but if you call this when needs\+Input is true the change of compression level will occur somewhere near before the end of the so far given input. 


\begin{DoxyParams}{Parameters}
{\em level} & the new compression level. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Strategy@{Set\+Strategy}}
\index{Set\+Strategy@{Set\+Strategy}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Strategy()}{SetStrategy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Strategy (\begin{DoxyParamCaption}\item[{\hyperlink{namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_a922c175879503e6b9e35641deccfbc40}{Deflate\+Strategy}}]{strategy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the compression strategy. Strategy is one of D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+T\+R\+A\+T\+E\+GY, H\+U\+F\+F\+M\+A\+N\+\_\+\+O\+N\+LY and F\+I\+L\+T\+E\+R\+ED. For the exact position where the strategy is changed, the same as for \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level()} applies. 


\begin{DoxyParams}{Parameters}
{\em strategy} & The new compression strategy. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a1d3cf927ab2a1e6c6a477d9e2d2a1e93}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Set\+Strategy@{Set\+Strategy}}
\index{Set\+Strategy@{Set\+Strategy}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Set\+Strategy()}{SetStrategy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Set\+Strategy (\begin{DoxyParamCaption}\item[{\hyperlink{namespace_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_a922c175879503e6b9e35641deccfbc40}{Deflate\+Strategy}}]{strategy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the compression strategy. Strategy is one of D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+T\+R\+A\+T\+E\+GY, H\+U\+F\+F\+M\+A\+N\+\_\+\+O\+N\+LY and F\+I\+L\+T\+E\+R\+ED. For the exact position where the strategy is changed, the same as for \hyperlink{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aeec1f91af74741790108b3af8f877b5e}{Set\+Level()} applies. 


\begin{DoxyParams}{Parameters}
{\em strategy} & The new compression strategy. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a48bb9f670d4d5783fe8d961c94abc6c5}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a48bb9f670d4d5783fe8d961c94abc6c5}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}}
\index{B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}{BEST\_COMPRESSION}}
{\footnotesize\ttfamily const int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+B\+E\+S\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON = 9}



The best and slowest compression level. This tries to find very long and distant string repetitions. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a2cdcb79df38a40a31551bf83e136c341}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a2cdcb79df38a40a31551bf83e136c341}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!B\+E\+S\+T\+\_\+\+S\+P\+E\+ED@{B\+E\+S\+T\+\_\+\+S\+P\+E\+ED}}
\index{B\+E\+S\+T\+\_\+\+S\+P\+E\+ED@{B\+E\+S\+T\+\_\+\+S\+P\+E\+ED}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{B\+E\+S\+T\+\_\+\+S\+P\+E\+ED}{BEST\_SPEED}}
{\footnotesize\ttfamily const int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+B\+E\+S\+T\+\_\+\+S\+P\+E\+ED = 1}



The worst but fastest compression level. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a46b1664d22d2ba8d08620b3ff848063b}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a46b1664d22d2ba8d08620b3ff848063b}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}{DEFAULT\_COMPRESSION}}
{\footnotesize\ttfamily const int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+D\+E\+F\+A\+U\+L\+T\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON = -\/1}



The default compression level. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a3d3465bd16292776ddcf2f5a6fa4c134}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a3d3465bd16292776ddcf2f5a6fa4c134}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!D\+E\+F\+L\+A\+T\+ED@{D\+E\+F\+L\+A\+T\+ED}}
\index{D\+E\+F\+L\+A\+T\+ED@{D\+E\+F\+L\+A\+T\+ED}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{D\+E\+F\+L\+A\+T\+ED}{DEFLATED}}
{\footnotesize\ttfamily const int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+D\+E\+F\+L\+A\+T\+ED = 8}



The compression method. This is the only method supported so far. There is no need to use this constant at all. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a7bbbdacd59167e196eef92c3753b37ff}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a7bbbdacd59167e196eef92c3753b37ff}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}}
\index{N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON@{N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON}{NO\_COMPRESSION}}
{\footnotesize\ttfamily const int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON = 0}



This level won\textquotesingle{}t compress at all but output uncompressed blocks. 



\subsection{Property Documentation}
\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a074fbfc52ac8f635b64b2c58cd2b3f95}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a074fbfc52ac8f635b64b2c58cd2b3f95}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Adler@{Adler}}
\index{Adler@{Adler}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Adler}{Adler}}
{\footnotesize\ttfamily int I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Adler\hspace{0.3cm}{\ttfamily [get]}}



Gets the current adler checksum of the data that was processed so far. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aabbabbf940655a8832a8ed57d8804fa7}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aabbabbf940655a8832a8ed57d8804fa7}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Is\+Finished@{Is\+Finished}}
\index{Is\+Finished@{Is\+Finished}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Is\+Finished}{IsFinished}}
{\footnotesize\ttfamily bool I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Is\+Finished\hspace{0.3cm}{\ttfamily [get]}}



Returns true if the stream was finished and no more output bytes are available. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aab8aa7baaad840eb260ff1e0385fe116}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_aab8aa7baaad840eb260ff1e0385fe116}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Is\+Needing\+Input@{Is\+Needing\+Input}}
\index{Is\+Needing\+Input@{Is\+Needing\+Input}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Is\+Needing\+Input}{IsNeedingInput}}
{\footnotesize\ttfamily bool I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Is\+Needing\+Input\hspace{0.3cm}{\ttfamily [get]}}



Returns true, if the input buffer is empty. You should then call set\+Input(). N\+O\+TE\+: This method can also return true when the stream was finished. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4693c429dd0f79c65497f95649da225e}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a4693c429dd0f79c65497f95649da225e}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Total\+In@{Total\+In}}
\index{Total\+In@{Total\+In}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Total\+In}{TotalIn}}
{\footnotesize\ttfamily long I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Total\+In\hspace{0.3cm}{\ttfamily [get]}}



Gets the number of input bytes processed so far. 

\mbox{\Hypertarget{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a5cd8c55b5c101ba971532affb54f88af}\label{class_i_c_sharp_code_1_1_sharp_zip_lib_1_1_zip_1_1_compression_1_1_deflater_a5cd8c55b5c101ba971532affb54f88af}} 
\index{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}!Total\+Out@{Total\+Out}}
\index{Total\+Out@{Total\+Out}!I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater@{I\+C\+Sharp\+Code\+::\+Sharp\+Zip\+Lib\+::\+Zip\+::\+Compression\+::\+Deflater}}
\subsubsection{\texorpdfstring{Total\+Out}{TotalOut}}
{\footnotesize\ttfamily long I\+C\+Sharp\+Code.\+Sharp\+Zip\+Lib.\+Zip.\+Compression.\+Deflater.\+Total\+Out\hspace{0.3cm}{\ttfamily [get]}}



Gets the number of output bytes so far. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Project/\+Utility/\+Sharp\+Z\+I\+P/src/\+Zip/\+Compression/Deflater.\+cs\end{DoxyCompactItemize}
